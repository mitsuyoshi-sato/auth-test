"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/openid-client@6.8.1";
exports.ids = ["vendor-chunks/openid-client@6.8.1"];
exports.modules = {

/***/ "(rsc)/../../node_modules/.pnpm/openid-client@6.8.1/node_modules/openid-client/build/index.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/openid-client@6.8.1/node_modules/openid-client/build/index.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthorizationResponseError: () => (/* reexport safe */ oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.AuthorizationResponseError),\n/* harmony export */   ClientError: () => (/* binding */ ClientError),\n/* harmony export */   ClientSecretBasic: () => (/* binding */ ClientSecretBasic),\n/* harmony export */   ClientSecretJwt: () => (/* binding */ ClientSecretJwt),\n/* harmony export */   ClientSecretPost: () => (/* binding */ ClientSecretPost),\n/* harmony export */   Configuration: () => (/* binding */ Configuration),\n/* harmony export */   None: () => (/* binding */ None),\n/* harmony export */   PrivateKeyJwt: () => (/* binding */ PrivateKeyJwt),\n/* harmony export */   ResponseBodyError: () => (/* reexport safe */ oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.ResponseBodyError),\n/* harmony export */   TlsClientAuth: () => (/* binding */ TlsClientAuth),\n/* harmony export */   WWWAuthenticateChallengeError: () => (/* reexport safe */ oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.WWWAuthenticateChallengeError),\n/* harmony export */   allowInsecureRequests: () => (/* binding */ allowInsecureRequests),\n/* harmony export */   authorizationCodeGrant: () => (/* binding */ authorizationCodeGrant),\n/* harmony export */   buildAuthorizationUrl: () => (/* binding */ buildAuthorizationUrl),\n/* harmony export */   buildAuthorizationUrlWithJAR: () => (/* binding */ buildAuthorizationUrlWithJAR),\n/* harmony export */   buildAuthorizationUrlWithPAR: () => (/* binding */ buildAuthorizationUrlWithPAR),\n/* harmony export */   buildEndSessionUrl: () => (/* binding */ buildEndSessionUrl),\n/* harmony export */   calculatePKCECodeChallenge: () => (/* binding */ calculatePKCECodeChallenge),\n/* harmony export */   clientCredentialsGrant: () => (/* binding */ clientCredentialsGrant),\n/* harmony export */   clockSkew: () => (/* binding */ clockSkew),\n/* harmony export */   clockTolerance: () => (/* binding */ clockTolerance),\n/* harmony export */   customFetch: () => (/* binding */ customFetch),\n/* harmony export */   discovery: () => (/* binding */ discovery),\n/* harmony export */   dynamicClientRegistration: () => (/* binding */ dynamicClientRegistration),\n/* harmony export */   enableDecryptingResponses: () => (/* binding */ enableDecryptingResponses),\n/* harmony export */   enableDetachedSignatureResponseChecks: () => (/* binding */ enableDetachedSignatureResponseChecks),\n/* harmony export */   enableNonRepudiationChecks: () => (/* binding */ enableNonRepudiationChecks),\n/* harmony export */   fetchProtectedResource: () => (/* binding */ fetchProtectedResource),\n/* harmony export */   fetchUserInfo: () => (/* binding */ fetchUserInfo),\n/* harmony export */   genericGrantRequest: () => (/* binding */ genericGrantRequest),\n/* harmony export */   getDPoPHandle: () => (/* binding */ getDPoPHandle),\n/* harmony export */   getJwksCache: () => (/* binding */ getJwksCache),\n/* harmony export */   implicitAuthentication: () => (/* binding */ implicitAuthentication),\n/* harmony export */   initiateBackchannelAuthentication: () => (/* binding */ initiateBackchannelAuthentication),\n/* harmony export */   initiateDeviceAuthorization: () => (/* binding */ initiateDeviceAuthorization),\n/* harmony export */   modifyAssertion: () => (/* binding */ modifyAssertion),\n/* harmony export */   pollBackchannelAuthenticationGrant: () => (/* binding */ pollBackchannelAuthenticationGrant),\n/* harmony export */   pollDeviceAuthorizationGrant: () => (/* binding */ pollDeviceAuthorizationGrant),\n/* harmony export */   randomDPoPKeyPair: () => (/* binding */ randomDPoPKeyPair),\n/* harmony export */   randomNonce: () => (/* binding */ randomNonce),\n/* harmony export */   randomPKCECodeVerifier: () => (/* binding */ randomPKCECodeVerifier),\n/* harmony export */   randomState: () => (/* binding */ randomState),\n/* harmony export */   refreshTokenGrant: () => (/* binding */ refreshTokenGrant),\n/* harmony export */   setJwksCache: () => (/* binding */ setJwksCache),\n/* harmony export */   skipStateCheck: () => (/* binding */ skipStateCheck),\n/* harmony export */   skipSubjectCheck: () => (/* binding */ skipSubjectCheck),\n/* harmony export */   tokenIntrospection: () => (/* binding */ tokenIntrospection),\n/* harmony export */   tokenRevocation: () => (/* binding */ tokenRevocation),\n/* harmony export */   useCodeIdTokenResponseType: () => (/* binding */ useCodeIdTokenResponseType),\n/* harmony export */   useIdTokenResponseType: () => (/* binding */ useIdTokenResponseType),\n/* harmony export */   useJwtResponseMode: () => (/* binding */ useJwtResponseMode)\n/* harmony export */ });\n/* harmony import */ var oauth4webapi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! oauth4webapi */ \"(rsc)/../../node_modules/.pnpm/oauth4webapi@3.8.2/node_modules/oauth4webapi/build/index.js\");\n/* harmony import */ var jose_jwe_compact_decrypt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jose/jwe/compact/decrypt */ \"(rsc)/../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/jwe/compact/decrypt.js\");\n/* harmony import */ var jose_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jose/errors */ \"(rsc)/../../node_modules/.pnpm/jose@6.1.0/node_modules/jose/dist/webapi/util/errors.js\");\n\n\n\nlet headers;\nlet USER_AGENT;\nif (typeof navigator === 'undefined' || !navigator.userAgent?.startsWith?.('Mozilla/5.0 ')) {\n    const NAME = 'openid-client';\n    const VERSION = 'v6.8.1';\n    USER_AGENT = `${NAME}/${VERSION}`;\n    headers = { 'user-agent': USER_AGENT };\n}\nconst int = (config) => {\n    return props.get(config);\n};\nlet props;\n\nlet tbi;\nfunction ClientSecretPost(clientSecret) {\n    if (clientSecret !== undefined) {\n        return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.ClientSecretPost(clientSecret);\n    }\n    tbi ||= new WeakMap();\n    return (as, client, body, headers) => {\n        let auth;\n        if (!(auth = tbi.get(client))) {\n            assertString(client.client_secret, '\"metadata.client_secret\"');\n            auth = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.ClientSecretPost(client.client_secret);\n            tbi.set(client, auth);\n        }\n        return auth(as, client, body, headers);\n    };\n}\nfunction assertString(input, it) {\n    if (typeof input !== 'string') {\n        throw CodedTypeError(`${it} must be a string`, ERR_INVALID_ARG_TYPE);\n    }\n    if (input.length === 0) {\n        throw CodedTypeError(`${it} must not be empty`, ERR_INVALID_ARG_VALUE);\n    }\n}\nfunction ClientSecretBasic(clientSecret) {\n    if (clientSecret !== undefined) {\n        return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.ClientSecretBasic(clientSecret);\n    }\n    tbi ||= new WeakMap();\n    return (as, client, body, headers) => {\n        let auth;\n        if (!(auth = tbi.get(client))) {\n            assertString(client.client_secret, '\"metadata.client_secret\"');\n            auth = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.ClientSecretBasic(client.client_secret);\n            tbi.set(client, auth);\n        }\n        return auth(as, client, body, headers);\n    };\n}\nfunction ClientSecretJwt(clientSecret, options) {\n    if (clientSecret !== undefined) {\n        return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.ClientSecretJwt(clientSecret, options);\n    }\n    tbi ||= new WeakMap();\n    return (as, client, body, headers) => {\n        let auth;\n        if (!(auth = tbi.get(client))) {\n            assertString(client.client_secret, '\"metadata.client_secret\"');\n            auth = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.ClientSecretJwt(client.client_secret, options);\n            tbi.set(client, auth);\n        }\n        return auth(as, client, body, headers);\n    };\n}\nfunction None() {\n    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.None();\n}\nfunction PrivateKeyJwt(clientPrivateKey, options) {\n    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.PrivateKeyJwt(clientPrivateKey, options);\n}\nfunction TlsClientAuth() {\n    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.TlsClientAuth();\n}\nconst skipStateCheck = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.skipStateCheck;\nconst skipSubjectCheck = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.skipSubjectCheck;\nconst customFetch = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch;\nconst modifyAssertion = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.modifyAssertion;\nconst clockSkew = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.clockSkew;\nconst clockTolerance = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.clockTolerance;\nconst ERR_INVALID_ARG_VALUE = 'ERR_INVALID_ARG_VALUE';\nconst ERR_INVALID_ARG_TYPE = 'ERR_INVALID_ARG_TYPE';\nfunction CodedTypeError(message, code, cause) {\n    const err = new TypeError(message, { cause });\n    Object.assign(err, { code });\n    return err;\n}\nfunction calculatePKCECodeChallenge(codeVerifier) {\n    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.calculatePKCECodeChallenge(codeVerifier);\n}\nfunction randomPKCECodeVerifier() {\n    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.generateRandomCodeVerifier();\n}\nfunction randomNonce() {\n    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.generateRandomNonce();\n}\nfunction randomState() {\n    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.generateRandomState();\n}\nclass ClientError extends Error {\n    code;\n    constructor(message, options) {\n        super(message, options);\n        this.name = this.constructor.name;\n        this.code = options?.code;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nconst decoder = new TextDecoder();\nfunction e(msg, cause, code) {\n    return new ClientError(msg, { cause, code });\n}\nfunction errorHandler(err) {\n    if (err instanceof TypeError ||\n        err instanceof ClientError ||\n        err instanceof oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.ResponseBodyError ||\n        err instanceof oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.AuthorizationResponseError ||\n        err instanceof oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.WWWAuthenticateChallengeError) {\n        throw err;\n    }\n    if (err instanceof oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.OperationProcessingError) {\n        switch (err.code) {\n            case oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.HTTP_REQUEST_FORBIDDEN:\n                throw e('only requests to HTTPS are allowed', err, err.code);\n            case oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.REQUEST_PROTOCOL_FORBIDDEN:\n                throw e('only requests to HTTP or HTTPS are allowed', err, err.code);\n            case oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.RESPONSE_IS_NOT_CONFORM:\n                throw e('unexpected HTTP response status code', err.cause, err.code);\n            case oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.RESPONSE_IS_NOT_JSON:\n                throw e('unexpected response content-type', err.cause, err.code);\n            case oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.PARSE_ERROR:\n                throw e('parsing error occured', err, err.code);\n            case oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.INVALID_RESPONSE:\n                throw e('invalid response encountered', err, err.code);\n            case oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.JWT_CLAIM_COMPARISON:\n                throw e('unexpected JWT claim value encountered', err, err.code);\n            case oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.JSON_ATTRIBUTE_COMPARISON:\n                throw e('unexpected JSON attribute value encountered', err, err.code);\n            case oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.JWT_TIMESTAMP_CHECK:\n                throw e('JWT timestamp claim value failed validation', err, err.code);\n            default:\n                throw e(err.message, err, err.code);\n        }\n    }\n    if (err instanceof oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.UnsupportedOperationError) {\n        throw e('unsupported operation', err, err.code);\n    }\n    if (err instanceof DOMException) {\n        switch (err.name) {\n            case 'OperationError':\n                throw e('runtime operation error', err, oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.UNSUPPORTED_OPERATION);\n            case 'NotSupportedError':\n                throw e('runtime unsupported operation', err, oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.UNSUPPORTED_OPERATION);\n            case 'TimeoutError':\n                throw e('operation timed out', err, 'OAUTH_TIMEOUT');\n            case 'AbortError':\n                throw e('operation aborted', err, 'OAUTH_ABORT');\n        }\n    }\n    throw new ClientError('something went wrong', { cause: err });\n}\nfunction randomDPoPKeyPair(alg, options) {\n    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.generateKeyPair(alg ?? 'ES256', {\n        extractable: options?.extractable,\n    })\n        .catch(errorHandler);\n}\nfunction handleEntraId(server, as, options) {\n    if (server.origin === 'https://login.microsoftonline.com' &&\n        (!options?.algorithm || options.algorithm === 'oidc')) {\n        as[kEntraId] = true;\n        return true;\n    }\n    return false;\n}\nfunction handleB2Clogin(server, options) {\n    if (server.hostname.endsWith('.b2clogin.com') &&\n        (!options?.algorithm || options.algorithm === 'oidc')) {\n        return true;\n    }\n    return false;\n}\nasync function dynamicClientRegistration(server, metadata, clientAuthentication, options) {\n    let as;\n    if (options?.flag === retry) {\n        as = options.as;\n    }\n    else {\n        as = await performDiscovery(server, options);\n    }\n    const clockSkew = metadata[oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.clockSkew] ?? 0;\n    const clockTolerance = metadata[oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.clockTolerance] ?? 30;\n    metadata = structuredClone(metadata);\n    const timeout = options?.timeout ?? 30;\n    const signal = AbortSignal.timeout(timeout * 1000);\n    let registered;\n    try {\n        registered = await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.dynamicClientRegistrationRequest(as, metadata, {\n            initialAccessToken: options?.initialAccessToken,\n            DPoP: options?.DPoP,\n            headers: new Headers(headers),\n            [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: options?.[customFetch],\n            [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: options?.execute?.includes(allowInsecureRequests),\n            signal,\n        })\n            .then(oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processDynamicClientRegistrationResponse);\n    }\n    catch (err) {\n        if (retryable(err, options)) {\n            return dynamicClientRegistration(server, metadata, clientAuthentication, {\n                ...options,\n                flag: retry,\n                as,\n            });\n        }\n        errorHandler(err);\n    }\n    registered[oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.clockSkew] = clockSkew;\n    registered[oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.clockTolerance] = clockTolerance;\n    const instance = new Configuration(as, registered.client_id, registered, clientAuthentication);\n    let internals = int(instance);\n    if (options?.[customFetch]) {\n        internals.fetch = options[customFetch];\n    }\n    if (options?.timeout) {\n        internals.timeout = options.timeout;\n    }\n    if (options?.execute) {\n        for (const extension of options.execute) {\n            extension(instance);\n        }\n    }\n    return instance;\n}\nasync function discovery(server, clientId, metadata, clientAuthentication, options) {\n    const as = await performDiscovery(server, options);\n    const instance = new Configuration(as, clientId, metadata, clientAuthentication);\n    let internals = int(instance);\n    if (options?.[customFetch]) {\n        internals.fetch = options[customFetch];\n    }\n    if (options?.timeout) {\n        internals.timeout = options.timeout;\n    }\n    if (options?.execute) {\n        for (const extension of options.execute) {\n            extension(instance);\n        }\n    }\n    return instance;\n}\nasync function performDiscovery(server, options) {\n    if (!(server instanceof URL)) {\n        throw CodedTypeError('\"server\" must be an instance of URL', ERR_INVALID_ARG_TYPE);\n    }\n    const resolve = !server.href.includes('/.well-known/');\n    const timeout = options?.timeout ?? 30;\n    const signal = AbortSignal.timeout(timeout * 1000);\n    const as = await (resolve\n        ? oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.discoveryRequest(server, {\n            algorithm: options?.algorithm,\n            [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: options?.[customFetch],\n            [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: options?.execute?.includes(allowInsecureRequests),\n            signal,\n            headers: new Headers(headers),\n        })\n        : (options?.[customFetch] || fetch)((() => {\n            oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.checkProtocol(server, options?.execute?.includes(allowInsecureRequests) ? false : true);\n            return server.href;\n        })(), {\n            headers: Object.fromEntries(new Headers({ accept: 'application/json', ...headers }).entries()),\n            body: undefined,\n            method: 'GET',\n            redirect: 'manual',\n            signal,\n        }))\n        .then((response) => oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processDiscoveryResponse(oauth4webapi__WEBPACK_IMPORTED_MODULE_0__._nodiscoverycheck, response))\n        .catch(errorHandler);\n    if (resolve && new URL(as.issuer).href !== server.href) {\n        handleEntraId(server, as, options) ||\n            handleB2Clogin(server, options) ||\n            (() => {\n                throw new ClientError('discovered metadata issuer does not match the expected issuer', {\n                    code: oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.JSON_ATTRIBUTE_COMPARISON,\n                    cause: {\n                        expected: server.href,\n                        body: as,\n                        attribute: 'issuer',\n                    },\n                });\n            })();\n    }\n    return as;\n}\nfunction isRsaOaep(input) {\n    return input.name === 'RSA-OAEP';\n}\nfunction isEcdh(input) {\n    return input.name === 'ECDH';\n}\nconst ecdhEs = 'ECDH-ES';\nconst ecdhEsA128Kw = 'ECDH-ES+A128KW';\nconst ecdhEsA192Kw = 'ECDH-ES+A192KW';\nconst ecdhEsA256Kw = 'ECDH-ES+A256KW';\nfunction checkEcdhAlg(algs, alg, pk) {\n    switch (alg) {\n        case undefined:\n            algs.add(ecdhEs);\n            algs.add(ecdhEsA128Kw);\n            algs.add(ecdhEsA192Kw);\n            algs.add(ecdhEsA256Kw);\n            break;\n        case ecdhEs:\n        case ecdhEsA128Kw:\n        case ecdhEsA192Kw:\n        case ecdhEsA256Kw:\n            algs.add(alg);\n            break;\n        default:\n            throw CodedTypeError('invalid key alg', ERR_INVALID_ARG_VALUE, { pk });\n    }\n}\nfunction enableDecryptingResponses(config, contentEncryptionAlgorithms = [\n    'A128GCM',\n    'A192GCM',\n    'A256GCM',\n    'A128CBC-HS256',\n    'A192CBC-HS384',\n    'A256CBC-HS512',\n], ...keys) {\n    if (int(config).decrypt !== undefined) {\n        throw new TypeError('enableDecryptingResponses can only be called on a given Configuration instance once');\n    }\n    if (keys.length === 0) {\n        throw CodedTypeError('no keys were provided', ERR_INVALID_ARG_VALUE);\n    }\n    const algs = new Set();\n    const normalized = [];\n    for (const pk of keys) {\n        let key;\n        if ('key' in pk) {\n            key = { key: pk.key };\n            if (typeof pk.alg === 'string')\n                key.alg = pk.alg;\n            if (typeof pk.kid === 'string')\n                key.kid = pk.kid;\n        }\n        else {\n            key = { key: pk };\n        }\n        if (key.key.type !== 'private') {\n            throw CodedTypeError('only private keys must be provided', ERR_INVALID_ARG_VALUE);\n        }\n        if (isRsaOaep(key.key.algorithm)) {\n            switch (key.key.algorithm.hash.name) {\n                case 'SHA-1':\n                case 'SHA-256':\n                case 'SHA-384':\n                case 'SHA-512': {\n                    let alg = 'RSA-OAEP';\n                    let sha;\n                    if ((sha = parseInt(key.key.algorithm.hash.name.slice(-3), 10))) {\n                        alg = `${alg}-${sha}`;\n                    }\n                    key.alg ||= alg;\n                    if (alg !== key.alg)\n                        throw CodedTypeError('invalid key alg', ERR_INVALID_ARG_VALUE, {\n                            pk,\n                        });\n                    algs.add(key.alg);\n                    break;\n                }\n                default:\n                    throw CodedTypeError('only SHA-512, SHA-384, SHA-256, and SHA-1 RSA-OAEP keys are supported', ERR_INVALID_ARG_VALUE);\n            }\n        }\n        else if (isEcdh(key.key.algorithm)) {\n            if (key.key.algorithm.namedCurve !== 'P-256') {\n                throw CodedTypeError('Only P-256 ECDH keys are supported', ERR_INVALID_ARG_VALUE);\n            }\n            checkEcdhAlg(algs, key.alg, pk);\n        }\n        else if (key.key.algorithm.name === 'X25519') {\n            checkEcdhAlg(algs, key.alg, pk);\n        }\n        else {\n            throw CodedTypeError('only RSA-OAEP, ECDH, or X25519 keys are supported', ERR_INVALID_ARG_VALUE);\n        }\n        normalized.push(key);\n    }\n    int(config).decrypt = async (jwe) => decrypt(normalized, jwe, contentEncryptionAlgorithms, [...algs]).catch(errorHandler);\n}\nfunction checkCryptoKey(key, alg, epk) {\n    if (alg.startsWith('RSA-OAEP')) {\n        return true;\n    }\n    if (alg.startsWith('ECDH-ES')) {\n        if (key.algorithm.name !== 'ECDH' && key.algorithm.name !== 'X25519') {\n            return false;\n        }\n        if (key.algorithm.name === 'ECDH') {\n            return epk?.crv === key.algorithm.namedCurve;\n        }\n        if (key.algorithm.name === 'X25519') {\n            return epk?.crv === 'X25519';\n        }\n    }\n    return false;\n}\nfunction selectCryptoKeyForDecryption(keys, alg, kid, epk) {\n    const { 0: key, length } = keys.filter((key) => {\n        if (kid !== key.kid) {\n            return false;\n        }\n        if (key.alg && alg !== key.alg) {\n            return false;\n        }\n        return checkCryptoKey(key.key, alg, epk);\n    });\n    if (!key) {\n        throw e('no applicable decryption key selected', undefined, 'OAUTH_DECRYPTION_FAILED');\n    }\n    if (length !== 1) {\n        throw e('multiple applicable decryption keys selected', undefined, 'OAUTH_DECRYPTION_FAILED');\n    }\n    return key.key;\n}\nasync function decrypt(keys, jwe, contentEncryptionAlgorithms, keyManagementAlgorithms) {\n    return decoder.decode((await (0,jose_jwe_compact_decrypt__WEBPACK_IMPORTED_MODULE_1__.compactDecrypt)(jwe, (header) => {\n        const { kid, alg, epk } = header;\n        return selectCryptoKeyForDecryption(keys, alg, kid, epk);\n    }, { keyManagementAlgorithms, contentEncryptionAlgorithms }).catch((err) => {\n        if (err instanceof jose_errors__WEBPACK_IMPORTED_MODULE_2__.JOSEError) {\n            throw e('decryption failed', err, 'OAUTH_DECRYPTION_FAILED');\n        }\n        errorHandler(err);\n    })).plaintext);\n}\nfunction getServerHelpers(metadata) {\n    return {\n        supportsPKCE: {\n            __proto__: null,\n            value(method = 'S256') {\n                return (metadata.code_challenge_methods_supported?.includes(method) === true);\n            },\n        },\n    };\n}\nfunction addServerHelpers(metadata) {\n    Object.defineProperties(metadata, getServerHelpers(metadata));\n}\nconst kEntraId = Symbol();\nclass Configuration {\n    constructor(server, clientId, metadata, clientAuthentication) {\n        if (typeof clientId !== 'string' || !clientId.length) {\n            throw CodedTypeError('\"clientId\" must be a non-empty string', ERR_INVALID_ARG_TYPE);\n        }\n        if (typeof metadata === 'string') {\n            metadata = { client_secret: metadata };\n        }\n        if (metadata?.client_id !== undefined && clientId !== metadata.client_id) {\n            throw CodedTypeError('\"clientId\" and \"metadata.client_id\" must be the same', ERR_INVALID_ARG_VALUE);\n        }\n        const client = {\n            ...structuredClone(metadata),\n            client_id: clientId,\n        };\n        client[oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.clockSkew] = metadata?.[oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.clockSkew] ?? 0;\n        client[oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.clockTolerance] = metadata?.[oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.clockTolerance] ?? 30;\n        let auth;\n        if (clientAuthentication) {\n            auth = clientAuthentication;\n        }\n        else {\n            if (typeof client.client_secret === 'string' &&\n                client.client_secret.length) {\n                auth = ClientSecretPost(client.client_secret);\n            }\n            else {\n                auth = None();\n            }\n        }\n        let c = Object.freeze(client);\n        const clone = structuredClone(server);\n        if (kEntraId in server) {\n            clone[oauth4webapi__WEBPACK_IMPORTED_MODULE_0__._expectedIssuer] = ({ claims: { tid } }) => server.issuer.replace('{tenantid}', tid);\n        }\n        let as = Object.freeze(clone);\n        props ||= new WeakMap();\n        props.set(this, {\n            __proto__: null,\n            as,\n            c,\n            auth,\n            tlsOnly: true,\n            jwksCache: {},\n        });\n    }\n    serverMetadata() {\n        const metadata = structuredClone(int(this).as);\n        addServerHelpers(metadata);\n        return metadata;\n    }\n    clientMetadata() {\n        const metadata = structuredClone(int(this).c);\n        return metadata;\n    }\n    get timeout() {\n        return int(this).timeout;\n    }\n    set timeout(value) {\n        int(this).timeout = value;\n    }\n    get [customFetch]() {\n        return int(this).fetch;\n    }\n    set [customFetch](value) {\n        int(this).fetch = value;\n    }\n}\nObject.freeze(Configuration.prototype);\nfunction getHelpers(response) {\n    let exp = undefined;\n    if (response.expires_in !== undefined) {\n        const now = new Date();\n        now.setSeconds(now.getSeconds() + response.expires_in);\n        exp = now.getTime();\n    }\n    return {\n        expiresIn: {\n            __proto__: null,\n            value() {\n                if (exp) {\n                    const now = Date.now();\n                    if (exp > now) {\n                        return Math.floor((exp - now) / 1000);\n                    }\n                    return 0;\n                }\n                return undefined;\n            },\n        },\n        claims: {\n            __proto__: null,\n            value() {\n                try {\n                    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.getValidatedIdTokenClaims(this);\n                }\n                catch {\n                    return undefined;\n                }\n            },\n        },\n    };\n}\nfunction addHelpers(response) {\n    Object.defineProperties(response, getHelpers(response));\n}\nfunction getDPoPHandle(config, keyPair, options) {\n    checkConfig(config);\n    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.DPoP(int(config).c, keyPair, options);\n}\nasync function handleRetryAfter(response, currentInterval, signal, throwIfInvalid = false) {\n    const retryAfter = response.headers.get('retry-after')?.trim();\n    if (retryAfter === undefined)\n        return;\n    let delaySeconds;\n    if (/^\\d+$/.test(retryAfter)) {\n        delaySeconds = parseInt(retryAfter, 10);\n    }\n    else {\n        const retryDate = new Date(retryAfter);\n        if (Number.isFinite(retryDate.getTime())) {\n            const now = new Date();\n            const delayMs = retryDate.getTime() - now.getTime();\n            if (delayMs > 0) {\n                delaySeconds = Math.ceil(delayMs / 1000);\n            }\n        }\n    }\n    if (throwIfInvalid && !Number.isFinite(delaySeconds)) {\n        throw new oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.OperationProcessingError('invalid Retry-After header value', { cause: response });\n    }\n    if (delaySeconds > currentInterval) {\n        await wait(delaySeconds - currentInterval, signal);\n    }\n}\nfunction wait(duration, signal) {\n    return new Promise((resolve, reject) => {\n        const waitStep = (remaining) => {\n            try {\n                signal.throwIfAborted();\n            }\n            catch (err) {\n                reject(err);\n                return;\n            }\n            if (remaining <= 0) {\n                resolve();\n                return;\n            }\n            const currentWait = Math.min(remaining, 5);\n            setTimeout(() => waitStep(remaining - currentWait), currentWait * 1000);\n        };\n        waitStep(duration);\n    });\n}\nasync function pollDeviceAuthorizationGrant(config, deviceAuthorizationResponse, parameters, options) {\n    checkConfig(config);\n    parameters = new URLSearchParams(parameters);\n    let interval = deviceAuthorizationResponse.interval ?? 5;\n    const pollingSignal = options?.signal ??\n        AbortSignal.timeout(deviceAuthorizationResponse.expires_in * 1000);\n    try {\n        await wait(interval, pollingSignal);\n    }\n    catch (err) {\n        errorHandler(err);\n    }\n    const { as, c, auth, fetch, tlsOnly, nonRepudiation, timeout, decrypt } = int(config);\n    const retryPoll = (updatedInterval, flag) => pollDeviceAuthorizationGrant(config, {\n        ...deviceAuthorizationResponse,\n        interval: updatedInterval,\n    }, parameters, {\n        ...options,\n        signal: pollingSignal,\n        flag,\n    });\n    const response = await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.deviceCodeGrantRequest(as, c, auth, deviceAuthorizationResponse.device_code, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        additionalParameters: parameters,\n        DPoP: options?.DPoP,\n        headers: new Headers(headers),\n        signal: pollingSignal.aborted ? pollingSignal : signal(timeout),\n    })\n        .catch(errorHandler);\n    if (response.status === 503 && response.headers.has('retry-after')) {\n        await handleRetryAfter(response, interval, pollingSignal, true);\n        await response.body?.cancel();\n        return retryPoll(interval);\n    }\n    const p = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processDeviceCodeResponse(as, c, response, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jweDecrypt]: decrypt,\n    });\n    let result;\n    try {\n        result = await p;\n    }\n    catch (err) {\n        if (retryable(err, options)) {\n            return retryPoll(interval, retry);\n        }\n        if (err instanceof oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.ResponseBodyError) {\n            switch (err.error) {\n                case 'slow_down':\n                    interval += 5;\n                case 'authorization_pending':\n                    await handleRetryAfter(err.response, interval, pollingSignal);\n                    return retryPoll(interval);\n            }\n        }\n        errorHandler(err);\n    }\n    result.id_token && (await nonRepudiation?.(response));\n    addHelpers(result);\n    return result;\n}\nasync function initiateDeviceAuthorization(config, parameters) {\n    checkConfig(config);\n    const { as, c, auth, fetch, tlsOnly, timeout } = int(config);\n    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.deviceAuthorizationRequest(as, c, auth, parameters, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        headers: new Headers(headers),\n        signal: signal(timeout),\n    })\n        .then((response) => oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processDeviceAuthorizationResponse(as, c, response))\n        .catch(errorHandler);\n}\nasync function initiateBackchannelAuthentication(config, parameters) {\n    checkConfig(config);\n    const { as, c, auth, fetch, tlsOnly, timeout } = int(config);\n    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.backchannelAuthenticationRequest(as, c, auth, parameters, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        headers: new Headers(headers),\n        signal: signal(timeout),\n    })\n        .then((response) => oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processBackchannelAuthenticationResponse(as, c, response))\n        .catch(errorHandler);\n}\nasync function pollBackchannelAuthenticationGrant(config, backchannelAuthenticationResponse, parameters, options) {\n    checkConfig(config);\n    parameters = new URLSearchParams(parameters);\n    let interval = backchannelAuthenticationResponse.interval ?? 5;\n    const pollingSignal = options?.signal ??\n        AbortSignal.timeout(backchannelAuthenticationResponse.expires_in * 1000);\n    try {\n        await wait(interval, pollingSignal);\n    }\n    catch (err) {\n        errorHandler(err);\n    }\n    const { as, c, auth, fetch, tlsOnly, nonRepudiation, timeout, decrypt } = int(config);\n    const retryPoll = (updatedInterval, flag) => pollBackchannelAuthenticationGrant(config, {\n        ...backchannelAuthenticationResponse,\n        interval: updatedInterval,\n    }, parameters, {\n        ...options,\n        signal: pollingSignal,\n        flag,\n    });\n    const response = await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.backchannelAuthenticationGrantRequest(as, c, auth, backchannelAuthenticationResponse.auth_req_id, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        additionalParameters: parameters,\n        DPoP: options?.DPoP,\n        headers: new Headers(headers),\n        signal: pollingSignal.aborted ? pollingSignal : signal(timeout),\n    })\n        .catch(errorHandler);\n    if (response.status === 503 && response.headers.has('retry-after')) {\n        await handleRetryAfter(response, interval, pollingSignal, true);\n        await response.body?.cancel();\n        return retryPoll(interval);\n    }\n    const p = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processBackchannelAuthenticationGrantResponse(as, c, response, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jweDecrypt]: decrypt,\n    });\n    let result;\n    try {\n        result = await p;\n    }\n    catch (err) {\n        if (retryable(err, options)) {\n            return retryPoll(interval, retry);\n        }\n        if (err instanceof oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.ResponseBodyError) {\n            switch (err.error) {\n                case 'slow_down':\n                    interval += 5;\n                case 'authorization_pending':\n                    await handleRetryAfter(err.response, interval, pollingSignal);\n                    return retryPoll(interval);\n            }\n        }\n        errorHandler(err);\n    }\n    result.id_token && (await nonRepudiation?.(response));\n    addHelpers(result);\n    return result;\n}\nfunction allowInsecureRequests(config) {\n    int(config).tlsOnly = false;\n}\nfunction setJwksCache(config, jwksCache) {\n    int(config).jwksCache = structuredClone(jwksCache);\n}\nfunction getJwksCache(config) {\n    const cache = int(config).jwksCache;\n    if (cache.uat) {\n        return cache;\n    }\n    return undefined;\n}\nfunction enableNonRepudiationChecks(config) {\n    checkConfig(config);\n    int(config).nonRepudiation = (response) => {\n        const { as, fetch, tlsOnly, timeout, jwksCache } = int(config);\n        return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.validateApplicationLevelSignature(as, response, {\n            [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n            [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n            headers: new Headers(headers),\n            signal: signal(timeout),\n            [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jwksCache]: jwksCache,\n        })\n            .catch(errorHandler);\n    };\n}\nfunction useJwtResponseMode(config) {\n    checkConfig(config);\n    const { hybrid, implicit } = int(config);\n    if (hybrid || implicit) {\n        throw e('JARM cannot be combined with a hybrid or implicit response types', undefined, oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.UNSUPPORTED_OPERATION);\n    }\n    int(config).jarm = (authorizationResponse, expectedState) => validateJARMResponse(config, authorizationResponse, expectedState);\n}\nfunction enableDetachedSignatureResponseChecks(config) {\n    if (!int(config).hybrid) {\n        throw e('\"code id_token\" response type must be configured to be used first', undefined, oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.UNSUPPORTED_OPERATION);\n    }\n    int(config).hybrid = (authorizationResponse, expectedNonce, expectedState, maxAge) => validateCodeIdTokenResponse(config, authorizationResponse, expectedNonce, expectedState, maxAge, true);\n}\nasync function implicitAuthentication(config, currentUrl, expectedNonce, checks) {\n    checkConfig(config);\n    if (!(currentUrl instanceof URL) &&\n        !webInstanceOf(currentUrl, 'Request')) {\n        throw CodedTypeError('\"currentUrl\" must be an instance of URL, or Request', ERR_INVALID_ARG_TYPE);\n    }\n    if (typeof expectedNonce !== 'string') {\n        throw CodedTypeError('\"expectedNonce\" must be a string', ERR_INVALID_ARG_TYPE);\n    }\n    const { as, c, fetch, tlsOnly, timeout, decrypt, implicit, jwksCache } = int(config);\n    if (!implicit) {\n        throw new TypeError('implicitAuthentication() cannot be used by clients using flows other than response_type=id_token');\n    }\n    let params;\n    if (!(currentUrl instanceof URL)) {\n        const request = currentUrl;\n        switch (request.method) {\n            case 'GET':\n                params = new URLSearchParams(new URL(request.url).hash.slice(1));\n                break;\n            case 'POST':\n                params = new URLSearchParams(await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.formPostResponse(request));\n                break;\n            default:\n                throw CodedTypeError('unexpected Request HTTP method', ERR_INVALID_ARG_VALUE);\n        }\n    }\n    else {\n        params = new URLSearchParams(currentUrl.hash.slice(1));\n    }\n    try {\n        {\n            const decoy = new URLSearchParams(params);\n            decoy.delete('id_token');\n            oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.validateAuthResponse({\n                ...as,\n                authorization_response_iss_parameter_supported: undefined,\n            }, c, decoy, checks?.expectedState);\n        }\n        {\n            const decoy = new Response(JSON.stringify({\n                access_token: 'decoy',\n                token_type: 'bearer',\n                id_token: params.get('id_token'),\n            }), {\n                headers: new Headers({ 'content-type': 'application/json' }),\n            });\n            const ref = await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processAuthorizationCodeResponse(as, c, decoy, {\n                expectedNonce,\n                maxAge: checks?.maxAge,\n                [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jweDecrypt]: decrypt,\n            });\n            await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.validateApplicationLevelSignature(as, decoy, {\n                [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n                [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n                headers: new Headers(headers),\n                signal: signal(timeout),\n                [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jwksCache]: jwksCache,\n            });\n            return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.getValidatedIdTokenClaims(ref);\n        }\n    }\n    catch (err) {\n        errorHandler(err);\n    }\n}\nfunction useCodeIdTokenResponseType(config) {\n    checkConfig(config);\n    const { jarm, implicit } = int(config);\n    if (jarm || implicit) {\n        throw e('\"code id_token\" response type cannot be combined with JARM or implicit response type', undefined, oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.UNSUPPORTED_OPERATION);\n    }\n    int(config).hybrid = (authorizationResponse, expectedNonce, expectedState, maxAge) => validateCodeIdTokenResponse(config, authorizationResponse, expectedNonce, expectedState, maxAge, false);\n}\nfunction useIdTokenResponseType(config) {\n    checkConfig(config);\n    const { jarm, hybrid } = int(config);\n    if (jarm || hybrid) {\n        throw e('\"id_token\" response type cannot be combined with JARM or hybrid response type', undefined, oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.UNSUPPORTED_OPERATION);\n    }\n    int(config).implicit = true;\n}\nfunction stripParams(url) {\n    url = new URL(url);\n    url.search = '';\n    url.hash = '';\n    return url.href;\n}\nfunction webInstanceOf(input, toStringTag) {\n    try {\n        return Object.getPrototypeOf(input)[Symbol.toStringTag] === toStringTag;\n    }\n    catch {\n        return false;\n    }\n}\nasync function authorizationCodeGrant(config, currentUrl, checks, tokenEndpointParameters, options) {\n    checkConfig(config);\n    if (options?.flag !== retry &&\n        !(currentUrl instanceof URL) &&\n        !webInstanceOf(currentUrl, 'Request')) {\n        throw CodedTypeError('\"currentUrl\" must be an instance of URL, or Request', ERR_INVALID_ARG_TYPE);\n    }\n    let authResponse;\n    let redirectUri;\n    const { as, c, auth, fetch, tlsOnly, jarm, hybrid, nonRepudiation, timeout, decrypt, implicit } = int(config);\n    if (options?.flag === retry) {\n        authResponse = options.authResponse;\n        redirectUri = options.redirectUri;\n    }\n    else {\n        if (!(currentUrl instanceof URL)) {\n            const request = currentUrl;\n            currentUrl = new URL(currentUrl.url);\n            switch (request.method) {\n                case 'GET':\n                    break;\n                case 'POST':\n                    const params = new URLSearchParams(await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.formPostResponse(request));\n                    if (hybrid) {\n                        currentUrl.hash = params.toString();\n                    }\n                    else {\n                        for (const [k, v] of params.entries()) {\n                            currentUrl.searchParams.append(k, v);\n                        }\n                    }\n                    break;\n                default:\n                    throw CodedTypeError('unexpected Request HTTP method', ERR_INVALID_ARG_VALUE);\n            }\n        }\n        redirectUri = stripParams(currentUrl);\n        switch (true) {\n            case !!jarm:\n                authResponse = await jarm(currentUrl, checks?.expectedState);\n                break;\n            case !!hybrid:\n                authResponse = await hybrid(currentUrl, checks?.expectedNonce, checks?.expectedState, checks?.maxAge);\n                break;\n            case !!implicit:\n                throw new TypeError('authorizationCodeGrant() cannot be used by response_type=id_token clients');\n            default:\n                try {\n                    authResponse = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.validateAuthResponse(as, c, currentUrl.searchParams, checks?.expectedState);\n                }\n                catch (err) {\n                    errorHandler(err);\n                }\n        }\n    }\n    const response = await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.authorizationCodeGrantRequest(as, c, auth, authResponse, redirectUri, checks?.pkceCodeVerifier || oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.nopkce, {\n        additionalParameters: tokenEndpointParameters,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        DPoP: options?.DPoP,\n        headers: new Headers(headers),\n        signal: signal(timeout),\n    })\n        .catch(errorHandler);\n    if (typeof checks?.expectedNonce === 'string' ||\n        typeof checks?.maxAge === 'number') {\n        checks.idTokenExpected = true;\n    }\n    const p = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processAuthorizationCodeResponse(as, c, response, {\n        expectedNonce: checks?.expectedNonce,\n        maxAge: checks?.maxAge,\n        requireIdToken: checks?.idTokenExpected,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jweDecrypt]: decrypt,\n    });\n    let result;\n    try {\n        result = await p;\n    }\n    catch (err) {\n        if (retryable(err, options)) {\n            return authorizationCodeGrant(config, undefined, checks, tokenEndpointParameters, {\n                ...options,\n                flag: retry,\n                authResponse: authResponse,\n                redirectUri: redirectUri,\n            });\n        }\n        errorHandler(err);\n    }\n    result.id_token && (await nonRepudiation?.(response));\n    addHelpers(result);\n    return result;\n}\nasync function validateJARMResponse(config, authorizationResponse, expectedState) {\n    const { as, c, fetch, tlsOnly, timeout, decrypt, jwksCache } = int(config);\n    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.validateJwtAuthResponse(as, c, authorizationResponse, expectedState, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        headers: new Headers(headers),\n        signal: signal(timeout),\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jweDecrypt]: decrypt,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jwksCache]: jwksCache,\n    })\n        .catch(errorHandler);\n}\nasync function validateCodeIdTokenResponse(config, authorizationResponse, expectedNonce, expectedState, maxAge, fapi) {\n    if (typeof expectedNonce !== 'string') {\n        throw CodedTypeError('\"expectedNonce\" must be a string', ERR_INVALID_ARG_TYPE);\n    }\n    if (expectedState !== undefined && typeof expectedState !== 'string') {\n        throw CodedTypeError('\"expectedState\" must be a string', ERR_INVALID_ARG_TYPE);\n    }\n    const { as, c, fetch, tlsOnly, timeout, decrypt, jwksCache } = int(config);\n    return (fapi\n        ? oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.validateDetachedSignatureResponse\n        : oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.validateCodeIdTokenResponse)(as, c, authorizationResponse, expectedNonce, expectedState, maxAge, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        headers: new Headers(headers),\n        signal: signal(timeout),\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jweDecrypt]: decrypt,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jwksCache]: jwksCache,\n    }).catch(errorHandler);\n}\nasync function refreshTokenGrant(config, refreshToken, parameters, options) {\n    checkConfig(config);\n    parameters = new URLSearchParams(parameters);\n    const { as, c, auth, fetch, tlsOnly, nonRepudiation, timeout, decrypt } = int(config);\n    const response = await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.refreshTokenGrantRequest(as, c, auth, refreshToken, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        additionalParameters: parameters,\n        DPoP: options?.DPoP,\n        headers: new Headers(headers),\n        signal: signal(timeout),\n    })\n        .catch(errorHandler);\n    const p = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processRefreshTokenResponse(as, c, response, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jweDecrypt]: decrypt,\n    });\n    let result;\n    try {\n        result = await p;\n    }\n    catch (err) {\n        if (retryable(err, options)) {\n            return refreshTokenGrant(config, refreshToken, parameters, {\n                ...options,\n                flag: retry,\n            });\n        }\n        errorHandler(err);\n    }\n    result.id_token && (await nonRepudiation?.(response));\n    addHelpers(result);\n    return result;\n}\nasync function clientCredentialsGrant(config, parameters, options) {\n    checkConfig(config);\n    parameters = new URLSearchParams(parameters);\n    const { as, c, auth, fetch, tlsOnly, timeout } = int(config);\n    const response = await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.clientCredentialsGrantRequest(as, c, auth, parameters, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        DPoP: options?.DPoP,\n        headers: new Headers(headers),\n        signal: signal(timeout),\n    })\n        .catch(errorHandler);\n    const p = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processClientCredentialsResponse(as, c, response);\n    let result;\n    try {\n        result = await p;\n    }\n    catch (err) {\n        if (retryable(err, options)) {\n            return clientCredentialsGrant(config, parameters, {\n                ...options,\n                flag: retry,\n            });\n        }\n        errorHandler(err);\n    }\n    addHelpers(result);\n    return result;\n}\nfunction buildAuthorizationUrl(config, parameters) {\n    checkConfig(config);\n    const { as, c, tlsOnly, hybrid, jarm, implicit } = int(config);\n    const authorizationEndpoint = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.resolveEndpoint(as, 'authorization_endpoint', false, tlsOnly);\n    parameters = new URLSearchParams(parameters);\n    if (!parameters.has('client_id')) {\n        parameters.set('client_id', c.client_id);\n    }\n    if (!parameters.has('request_uri') && !parameters.has('request')) {\n        if (!parameters.has('response_type')) {\n            parameters.set('response_type', hybrid ? 'code id_token' : implicit ? 'id_token' : 'code');\n        }\n        if (implicit && !parameters.has('nonce')) {\n            throw CodedTypeError('response_type=id_token clients must provide a nonce parameter in their authorization request parameters', ERR_INVALID_ARG_VALUE);\n        }\n        if (jarm) {\n            parameters.set('response_mode', 'jwt');\n        }\n    }\n    for (const [k, v] of parameters.entries()) {\n        authorizationEndpoint.searchParams.append(k, v);\n    }\n    return authorizationEndpoint;\n}\nasync function buildAuthorizationUrlWithJAR(config, parameters, signingKey, options) {\n    checkConfig(config);\n    const authorizationEndpoint = buildAuthorizationUrl(config, parameters);\n    parameters = authorizationEndpoint.searchParams;\n    if (!signingKey) {\n        throw CodedTypeError('\"signingKey\" must be provided', ERR_INVALID_ARG_VALUE);\n    }\n    const { as, c } = int(config);\n    const request = await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.issueRequestObject(as, c, parameters, signingKey, options)\n        .catch(errorHandler);\n    return buildAuthorizationUrl(config, { request });\n}\nasync function buildAuthorizationUrlWithPAR(config, parameters, options) {\n    checkConfig(config);\n    const authorizationEndpoint = buildAuthorizationUrl(config, parameters);\n    const { as, c, auth, fetch, tlsOnly, timeout } = int(config);\n    const response = await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.pushedAuthorizationRequest(as, c, auth, authorizationEndpoint.searchParams, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        DPoP: options?.DPoP,\n        headers: new Headers(headers),\n        signal: signal(timeout),\n    })\n        .catch(errorHandler);\n    const p = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processPushedAuthorizationResponse(as, c, response);\n    let result;\n    try {\n        result = await p;\n    }\n    catch (err) {\n        if (retryable(err, options)) {\n            return buildAuthorizationUrlWithPAR(config, parameters, {\n                ...options,\n                flag: retry,\n            });\n        }\n        errorHandler(err);\n    }\n    return buildAuthorizationUrl(config, { request_uri: result.request_uri });\n}\nfunction buildEndSessionUrl(config, parameters) {\n    checkConfig(config);\n    const { as, c, tlsOnly } = int(config);\n    const endSessionEndpoint = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.resolveEndpoint(as, 'end_session_endpoint', false, tlsOnly);\n    parameters = new URLSearchParams(parameters);\n    if (!parameters.has('client_id')) {\n        parameters.set('client_id', c.client_id);\n    }\n    for (const [k, v] of parameters.entries()) {\n        endSessionEndpoint.searchParams.append(k, v);\n    }\n    return endSessionEndpoint;\n}\nfunction checkConfig(input) {\n    if (!(input instanceof Configuration)) {\n        throw CodedTypeError('\"config\" must be an instance of Configuration', ERR_INVALID_ARG_TYPE);\n    }\n    if (Object.getPrototypeOf(input) !== Configuration.prototype) {\n        throw CodedTypeError('subclassing Configuration is not allowed', ERR_INVALID_ARG_VALUE);\n    }\n}\nfunction signal(timeout) {\n    return timeout ? AbortSignal.timeout(timeout * 1000) : undefined;\n}\nasync function fetchUserInfo(config, accessToken, expectedSubject, options) {\n    checkConfig(config);\n    const { as, c, fetch, tlsOnly, nonRepudiation, timeout, decrypt } = int(config);\n    const response = await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.userInfoRequest(as, c, accessToken, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        DPoP: options?.DPoP,\n        headers: new Headers(headers),\n        signal: signal(timeout),\n    })\n        .catch(errorHandler);\n    let exec = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processUserInfoResponse(as, c, expectedSubject, response, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jweDecrypt]: decrypt,\n    });\n    let result;\n    try {\n        result = await exec;\n    }\n    catch (err) {\n        if (retryable(err, options)) {\n            return fetchUserInfo(config, accessToken, expectedSubject, {\n                ...options,\n                flag: retry,\n            });\n        }\n        errorHandler(err);\n    }\n    oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.getContentType(response) === 'application/jwt' &&\n        (await nonRepudiation?.(response));\n    return result;\n}\nfunction retryable(err, options) {\n    if (options?.DPoP && options.flag !== retry) {\n        return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.isDPoPNonceError(err);\n    }\n    return false;\n}\nasync function tokenIntrospection(config, token, parameters) {\n    checkConfig(config);\n    const { as, c, auth, fetch, tlsOnly, nonRepudiation, timeout, decrypt } = int(config);\n    const response = await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.introspectionRequest(as, c, auth, token, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        additionalParameters: new URLSearchParams(parameters),\n        headers: new Headers(headers),\n        signal: signal(timeout),\n    })\n        .catch(errorHandler);\n    const result = await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processIntrospectionResponse(as, c, response, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jweDecrypt]: decrypt,\n    })\n        .catch(errorHandler);\n    oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.getContentType(response) === 'application/token-introspection+jwt' &&\n        (await nonRepudiation?.(response));\n    return result;\n}\nconst retry = Symbol();\nasync function genericGrantRequest(config, grantType, parameters, options) {\n    checkConfig(config);\n    const { as, c, auth, fetch, tlsOnly, timeout, decrypt } = int(config);\n    const result = await oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.genericTokenEndpointRequest(as, c, auth, grantType, new URLSearchParams(parameters), {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        DPoP: options?.DPoP,\n        headers: new Headers(headers),\n        signal: signal(timeout),\n    })\n        .then((response) => {\n        let recognizedTokenTypes;\n        if (grantType === 'urn:ietf:params:oauth:grant-type:token-exchange') {\n            recognizedTokenTypes = { n_a: () => { } };\n        }\n        return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processGenericTokenEndpointResponse(as, c, response, {\n            [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.jweDecrypt]: decrypt,\n            recognizedTokenTypes,\n        });\n    })\n        .catch(errorHandler);\n    addHelpers(result);\n    return result;\n}\nasync function tokenRevocation(config, token, parameters) {\n    checkConfig(config);\n    const { as, c, auth, fetch, tlsOnly, timeout } = int(config);\n    return oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.revocationRequest(as, c, auth, token, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        additionalParameters: new URLSearchParams(parameters),\n        headers: new Headers(headers),\n        signal: signal(timeout),\n    })\n        .then(oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.processRevocationResponse)\n        .catch(errorHandler);\n}\nasync function fetchProtectedResource(config, accessToken, url, method, body, headers, options) {\n    checkConfig(config);\n    headers ||= new Headers();\n    if (!headers.has('user-agent')) {\n        headers.set('user-agent', USER_AGENT);\n    }\n    const { fetch, tlsOnly, timeout } = int(config);\n    const exec = oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.protectedResourceRequest(accessToken, method, url, headers, body, {\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.customFetch]: fetch,\n        [oauth4webapi__WEBPACK_IMPORTED_MODULE_0__.allowInsecureRequests]: !tlsOnly,\n        DPoP: options?.DPoP,\n        signal: signal(timeout),\n    });\n    let result;\n    try {\n        result = await exec;\n    }\n    catch (err) {\n        if (retryable(err, options)) {\n            return fetchProtectedResource(config, accessToken, url, method, body, headers, {\n                ...options,\n                flag: retry,\n            });\n        }\n        errorHandler(err);\n    }\n    return result;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL29wZW5pZC1jbGllbnRANi44LjEvbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXNDO0FBQ29CO0FBQ2xCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSyxHQUFHLFFBQVE7QUFDcEMsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNkc7QUFDN0c7QUFDTztBQUNQO0FBQ0EsZUFBZSwwREFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBEQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQSxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBO0FBQ087QUFDUDtBQUNBLGVBQWUsMkRBQXVCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyREFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxlQUFlLHlEQUFxQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseURBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsOENBQVU7QUFDckI7QUFDTztBQUNQLFdBQVcsdURBQW1CO0FBQzlCO0FBQ087QUFDUCxXQUFXLHVEQUFtQjtBQUM5QjtBQUNPLHVCQUF1Qix3REFBb0I7QUFDM0MseUJBQXlCLDBEQUFzQjtBQUMvQyxvQkFBb0IscURBQWlCO0FBQ3JDLHdCQUF3Qix5REFBcUI7QUFDN0Msa0JBQWtCLG1EQUFlO0FBQ2pDLHVCQUF1Qix3REFBb0I7QUFDbEQ7QUFDQTtBQUNBO0FB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RTtBQUM1RSwyQkFBMkIsOERBQ0U7QUFDN0IsU0FBUyxxREFBaUI7QUFDMUIsU0FBUywrREFBMkI7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EseUJBQXlCLHNFQUNZO0FBQ3JDLFNBQVMsb0RBQWdCO0FBQ3pCLEtBQUs7QUFDTDtBQUNBLElBQUksd0RBQW9CO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLFlBQVksZ0RBQWdEO0FBQzVELHlCQUF5QixxRUFDVztBQUNwQyxTQUFTLHFEQUFpQjtBQUMxQixTQUFTLCtEQUEyQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EsZUFBZSw2RUFBeUM7QUFDeEQsYUFBYSxvREFBZ0I7QUFDN0I7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLFlBQVksdUNBQXVDO0FBQ25ELFdBQVcsMkRBQ2U7QUFDMUIsU0FBUyxxREFBaUI7QUFDMUIsU0FBUywrREFBMkI7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWMsbUVBQStCO0FBQzdDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBCQUEwQjtBQUN0QyxpQkFBaUIsa0VBQThCO0FBQy9DLFNBQVMscURBQWlCO0FBQzFCLFNBQVMsK0RBQTJCO0FBQ3BDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21pdHN1eW9zaGkvRGVza3RvcC9hdXRoLXRlc3Qvbm9kZV9tb2R1bGVzLy5wbnBtL29wZW5pZC1jbGllbnRANi44LjEvbm9kZV9tb2R1bGVzL29wZW5pZC1jbGllbnQvYnVpbGQvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgb2F1dGggZnJvbSAnb2F1dGg0d2ViYXBpJztcbmltcG9ydCB7IGNvbXBhY3REZWNyeXB0IH0gZnJvbSAnam9zZS9qd2UvY29tcGFjdC9kZWNyeXB0JztcbmltcG9ydCB7IEpPU0VFcnJvciB9IGZyb20gJ2pvc2UvZXJyb3JzJztcbmxldCBoZWFkZXJzO1xubGV0IFVTRVJfQUdFTlQ7XG5pZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgIW5hdmlnYXRvci51c2VyQWdlbnQ/LnN0YXJ0c1dpdGg/LignTW96aWxsYS81LjAgJykpIHtcbiAgICBjb25zdCBOQU1FID0gJ29wZW5pZC1jbGllbnQnO1xuICAgIGNvbnN0IFZFUlNJT04gPSAndjYuOC4xJztcbiAgICBVU0VSX0FHRU5UID0gYCR7TkFNRX0vJHtWRVJTSU9OfWA7XG4gICAgaGVhZGVycyA9IHsgJ3VzZXItYWdlbnQnOiBVU0VSX0FHRU5UIH07XG59XG5jb25zdCBpbnQgPSAoY29uZmlnKSA9PiB7XG4gICAgcmV0dXJuIHByb3BzLmdldChjb25maWcpO1xufTtcbmxldCBwcm9wcztcbmV4cG9ydCB7IEF1dGhvcml6YXRpb25SZXNwb25zZUVycm9yLCBSZXNwb25zZUJvZHlFcnJvciwgV1dXQXV0aGVudGljYXRlQ2hhbGxlbmdlRXJyb3IsIH0gZnJvbSAnb2F1dGg0d2ViYXBpJztcbmxldCB0Ymk7XG5leHBvcnQgZnVuY3Rpb24gQ2xpZW50U2VjcmV0UG9zdChjbGllbnRTZWNyZXQpIHtcbiAgICBpZiAoY2xpZW50U2VjcmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG9hdXRoLkNsaWVudFNlY3JldFBvc3QoY2xpZW50U2VjcmV0KTtcbiAgICB9XG4gICAgdGJpIHx8PSBuZXcgV2Vha01hcCgpO1xuICAgIHJldHVybiAoYXMsIGNsaWVudCwgYm9keSwgaGVhZGVycykgPT4ge1xuICAgICAgICBsZXQgYXV0aDtcbiAgICAgICAgaWYgKCEoYXV0aCA9IHRiaS5nZXQoY2xpZW50KSkpIHtcbiAgICAgICAgICAgIGFzc2VydFN0cmluZyhjbGllbnQuY2xpZW50X3NlY3JldCwgJ1wibWV0YWRhdGEuY2xpZW50X3NlY3JldFwiJyk7XG4gICAgICAgICAgICBhdXRoID0gb2F1dGguQ2xpZW50U2VjcmV0UG9zdChjbGllbnQuY2xpZW50X3NlY3JldCk7XG4gICAgICAgICAgICB0Ymkuc2V0KGNsaWVudCwgYXV0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF1dGgoYXMsIGNsaWVudCwgYm9keSwgaGVhZGVycyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFzc2VydFN0cmluZyhpbnB1dCwgaXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcihgJHtpdH0gbXVzdCBiZSBhIHN0cmluZ2AsIEVSUl9JTlZBTElEX0FSR19UWVBFKTtcbiAgICB9XG4gICAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcihgJHtpdH0gbXVzdCBub3QgYmUgZW1wdHlgLCBFUlJfSU5WQUxJRF9BUkdfVkFMVUUpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBDbGllbnRTZWNyZXRCYXNpYyhjbGllbnRTZWNyZXQpIHtcbiAgICBpZiAoY2xpZW50U2VjcmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG9hdXRoLkNsaWVudFNlY3JldEJhc2ljKGNsaWVudFNlY3JldCk7XG4gICAgfVxuICAgIHRiaSB8fD0gbmV3IFdlYWtNYXAoKTtcbiAgICByZXR1cm4gKGFzLCBjbGllbnQsIGJvZHksIGhlYWRlcnMpID0+IHtcbiAgICAgICAgbGV0IGF1dGg7XG4gICAgICAgIGlmICghKGF1dGggPSB0YmkuZ2V0KGNsaWVudCkpKSB7XG4gICAgICAgICAgICBhc3NlcnRTdHJpbmcoY2xpZW50LmNsaWVudF9zZWNyZXQsICdcIm1ldGFkYXRhLmNsaWVudF9zZWNyZXRcIicpO1xuICAgICAgICAgICAgYXV0aCA9IG9hdXRoLkNsaWVudFNlY3JldEJhc2ljKGNsaWVudC5jbGllbnRfc2VjcmV0KTtcbiAgICAgICAgICAgIHRiaS5zZXQoY2xpZW50LCBhdXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXV0aChhcywgY2xpZW50LCBib2R5LCBoZWFkZXJzKTtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIENsaWVudFNlY3JldEp3dChjbGllbnRTZWNyZXQsIG9wdGlvbnMpIHtcbiAgICBpZiAoY2xpZW50U2VjcmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG9hdXRoLkNsaWVudFNlY3JldEp3dChjbGllbnRTZWNyZXQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICB0YmkgfHw9IG5ldyBXZWFrTWFwKCk7XG4gICAgcmV0dXJuIChhcywgY2xpZW50LCBib2R5LCBoZWFkZXJzKSA9PiB7XG4gICAgICAgIGxldCBhdXRoO1xuICAgICAgICBpZiAoIShhdXRoID0gdGJpLmdldChjbGllbnQpKSkge1xuICAgICAgICAgICAgYXNzZXJ0U3RyaW5nKGNsaWVudC5jbGllbnRfc2VjcmV0LCAnXCJtZXRhZGF0YS5jbGllbnRfc2VjcmV0XCInKTtcbiAgICAgICAgICAgIGF1dGggPSBvYXV0aC5DbGllbnRTZWNyZXRKd3QoY2xpZW50LmNsaWVudF9zZWNyZXQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGJpLnNldChjbGllbnQsIGF1dGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdXRoKGFzLCBjbGllbnQsIGJvZHksIGhlYWRlcnMpO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gTm9uZSgpIHtcbiAgICByZXR1cm4gb2F1dGguTm9uZSgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIFByaXZhdGVLZXlKd3QoY2xpZW50UHJpdmF0ZUtleSwgb3B0aW9ucykge1xuICAgIHJldHVybiBvYXV0aC5Qcml2YXRlS2V5Snd0KGNsaWVudFByaXZhdGVLZXksIG9wdGlvbnMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIFRsc0NsaWVudEF1dGgoKSB7XG4gICAgcmV0dXJuIG9hdXRoLlRsc0NsaWVudEF1dGgoKTtcbn1cbmV4cG9ydCBjb25zdCBza2lwU3RhdGVDaGVjayA9IG9hdXRoLnNraXBTdGF0ZUNoZWNrO1xuZXhwb3J0IGNvbnN0IHNraXBTdWJqZWN0Q2hlY2sgPSBvYXV0aC5za2lwU3ViamVjdENoZWNrO1xuZXhwb3J0IGNvbnN0IGN1c3RvbUZldGNoID0gb2F1dGguY3VzdG9tRmV0Y2g7XG5leHBvcnQgY29uc3QgbW9kaWZ5QXNzZXJ0aW9uID0gb2F1dGgubW9kaWZ5QXNzZXJ0aW9uO1xuZXhwb3J0IGNvbnN0IGNsb2NrU2tldyA9IG9hdXRoLmNsb2NrU2tldztcbmV4cG9ydCBjb25zdCBjbG9ja1RvbGVyYW5jZSA9IG9hdXRoLmNsb2NrVG9sZXJhbmNlO1xuY29uc3QgRVJSX0lOVkFMSURfQVJHX1ZBTFVFID0gJ0VSUl9JTlZBTElEX0FSR19WQUxVRSc7XG5jb25zdCBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9ICdFUlJfSU5WQUxJRF9BUkdfVFlQRSc7XG5mdW5jdGlvbiBDb2RlZFR5cGVFcnJvcihtZXNzYWdlLCBjb2RlLCBjYXVzZSkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBUeXBlRXJyb3IobWVzc2FnZSwgeyBjYXVzZSB9KTtcbiAgICBPYmplY3QuYXNzaWduKGVyciwgeyBjb2RlIH0pO1xuICAgIHJldHVybiBlcnI7XG59XG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlUEtDRUNvZGVDaGFsbGVuZ2UoY29kZVZlcmlmaWVyKSB7XG4gICAgcmV0dXJuIG9hdXRoLmNhbGN1bGF0ZVBLQ0VDb2RlQ2hhbGxlbmdlKGNvZGVWZXJpZmllcik7XG59XG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tUEtDRUNvZGVWZXJpZmllcigpIHtcbiAgICByZXR1cm4gb2F1dGguZ2VuZXJhdGVSYW5kb21Db2RlVmVyaWZpZXIoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21Ob25jZSgpIHtcbiAgICByZXR1cm4gb2F1dGguZ2VuZXJhdGVSYW5kb21Ob25jZSgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbVN0YXRlKCkge1xuICAgIHJldHVybiBvYXV0aC5nZW5lcmF0ZVJhbmRvbVN0YXRlKCk7XG59XG5leHBvcnQgY2xhc3MgQ2xpZW50RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29kZTtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIHRoaXMuY29kZSA9IG9wdGlvbnM/LmNvZGU7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlPy4odGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgfVxufVxuY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuZnVuY3Rpb24gZShtc2csIGNhdXNlLCBjb2RlKSB7XG4gICAgcmV0dXJuIG5ldyBDbGllbnRFcnJvcihtc2csIHsgY2F1c2UsIGNvZGUgfSk7XG59XG5mdW5jdGlvbiBlcnJvckhhbmRsZXIoZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIFR5cGVFcnJvciB8fFxuICAgICAgICBlcnIgaW5zdGFuY2VvZiBDbGllbnRFcnJvciB8fFxuICAgICAgICBlcnIgaW5zdGFuY2VvZiBvYXV0aC5SZXNwb25zZUJvZHlFcnJvciB8fFxuICAgICAgICBlcnIgaW5zdGFuY2VvZiBvYXV0aC5BdXRob3JpemF0aW9uUmVzcG9uc2VFcnJvciB8fFxuICAgICAgICBlcnIgaW5zdGFuY2VvZiBvYXV0aC5XV1dBdXRoZW50aWNhdGVDaGFsbGVuZ2VFcnJvcikge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBvYXV0aC5PcGVyYXRpb25Qcm9jZXNzaW5nRXJyb3IpIHtcbiAgICAgICAgc3dpdGNoIChlcnIuY29kZSkge1xuICAgICAgICAgICAgY2FzZSBvYXV0aC5IVFRQX1JFUVVFU1RfRk9SQklEREVOOlxuICAgICAgICAgICAgICAgIHRocm93IGUoJ29ubHkgcmVxdWVzdHMgdG8gSFRUUFMgYXJlIGFsbG93ZWQnLCBlcnIsIGVyci5jb2RlKTtcbiAgICAgICAgICAgIGNhc2Ugb2F1dGguUkVRVUVTVF9QUk9UT0NPTF9GT1JCSURERU46XG4gICAgICAgICAgICAgICAgdGhyb3cgZSgnb25seSByZXF1ZXN0cyB0byBIVFRQIG9yIEhUVFBTIGFyZSBhbGxvd2VkJywgZXJyLCBlcnIuY29kZSk7XG4gICAgICAgICAgICBjYXNlIG9hdXRoLlJFU1BPTlNFX0lTX05PVF9DT05GT1JNOlxuICAgICAgICAgICAgICAgIHRocm93IGUoJ3VuZXhwZWN0ZWQgSFRUUCByZXNwb25zZSBzdGF0dXMgY29kZScsIGVyci5jYXVzZSwgZXJyLmNvZGUpO1xuICAgICAgICAgICAgY2FzZSBvYXV0aC5SRVNQT05TRV9JU19OT1RfSlNPTjpcbiAgICAgICAgICAgICAgICB0aHJvdyBlKCd1bmV4cGVjdGVkIHJlc3BvbnNlIGNvbnRlbnQtdHlwZScsIGVyci5jYXVzZSwgZXJyLmNvZGUpO1xuICAgICAgICAgICAgY2FzZSBvYXV0aC5QQVJTRV9FUlJPUjpcbiAgICAgICAgICAgICAgICB0aHJvdyBlKCdwYXJzaW5nIGVycm9yIG9jY3VyZWQnLCBlcnIsIGVyci5jb2RlKTtcbiAgICAgICAgICAgIGNhc2Ugb2F1dGguSU5WQUxJRF9SRVNQT05TRTpcbiAgICAgICAgICAgICAgICB0aHJvdyBlKCdpbnZhbGlkIHJlc3BvbnNlIGVuY291bnRlcmVkJywgZXJyLCBlcnIuY29kZSk7XG4gICAgICAgICAgICBjYXNlIG9hdXRoLkpXVF9DTEFJTV9DT01QQVJJU09OOlxuICAgICAgICAgICAgICAgIHRocm93IGUoJ3VuZXhwZWN0ZWQgSldUIGNsYWltIHZhbHVlIGVuY291bnRlcmVkJywgZXJyLCBlcnIuY29kZSk7XG4gICAgICAgICAgICBjYXNlIG9hdXRoLkpTT05fQVRUUklCVVRFX0NPTVBBUklTT046XG4gICAgICAgICAgICAgICAgdGhyb3cgZSgndW5leHBlY3RlZCBKU09OIGF0dHJpYnV0ZSB2YWx1ZSBlbmNvdW50ZXJlZCcsIGVyciwgZXJyLmNvZGUpO1xuICAgICAgICAgICAgY2FzZSBvYXV0aC5KV1RfVElNRVNUQU1QX0NIRUNLOlxuICAgICAgICAgICAgICAgIHRocm93IGUoJ0pXVCB0aW1lc3RhbXAgY2xhaW0gdmFsdWUgZmFpbGVkIHZhbGlkYXRpb24nLCBlcnIsIGVyci5jb2RlKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgZShlcnIubWVzc2FnZSwgZXJyLCBlcnIuY29kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIG9hdXRoLlVuc3VwcG9ydGVkT3BlcmF0aW9uRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZSgndW5zdXBwb3J0ZWQgb3BlcmF0aW9uJywgZXJyLCBlcnIuY29kZSk7XG4gICAgfVxuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBET01FeGNlcHRpb24pIHtcbiAgICAgICAgc3dpdGNoIChlcnIubmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnT3BlcmF0aW9uRXJyb3InOlxuICAgICAgICAgICAgICAgIHRocm93IGUoJ3J1bnRpbWUgb3BlcmF0aW9uIGVycm9yJywgZXJyLCBvYXV0aC5VTlNVUFBPUlRFRF9PUEVSQVRJT04pO1xuICAgICAgICAgICAgY2FzZSAnTm90U3VwcG9ydGVkRXJyb3InOlxuICAgICAgICAgICAgICAgIHRocm93IGUoJ3J1bnRpbWUgdW5zdXBwb3J0ZWQgb3BlcmF0aW9uJywgZXJyLCBvYXV0aC5VTlNVUFBPUlRFRF9PUEVSQVRJT04pO1xuICAgICAgICAgICAgY2FzZSAnVGltZW91dEVycm9yJzpcbiAgICAgICAgICAgICAgICB0aHJvdyBlKCdvcGVyYXRpb24gdGltZWQgb3V0JywgZXJyLCAnT0FVVEhfVElNRU9VVCcpO1xuICAgICAgICAgICAgY2FzZSAnQWJvcnRFcnJvcic6XG4gICAgICAgICAgICAgICAgdGhyb3cgZSgnb3BlcmF0aW9uIGFib3J0ZWQnLCBlcnIsICdPQVVUSF9BQk9SVCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBDbGllbnRFcnJvcignc29tZXRoaW5nIHdlbnQgd3JvbmcnLCB7IGNhdXNlOiBlcnIgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tRFBvUEtleVBhaXIoYWxnLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9hdXRoXG4gICAgICAgIC5nZW5lcmF0ZUtleVBhaXIoYWxnID8/ICdFUzI1NicsIHtcbiAgICAgICAgZXh0cmFjdGFibGU6IG9wdGlvbnM/LmV4dHJhY3RhYmxlLFxuICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnJvckhhbmRsZXIpO1xufVxuZnVuY3Rpb24gaGFuZGxlRW50cmFJZChzZXJ2ZXIsIGFzLCBvcHRpb25zKSB7XG4gICAgaWYgKHNlcnZlci5vcmlnaW4gPT09ICdodHRwczovL2xvZ2luLm1pY3Jvc29mdG9ubGluZS5jb20nICYmXG4gICAgICAgICghb3B0aW9ucz8uYWxnb3JpdGhtIHx8IG9wdGlvbnMuYWxnb3JpdGhtID09PSAnb2lkYycpKSB7XG4gICAgICAgIGFzW2tFbnRyYUlkXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBoYW5kbGVCMkNsb2dpbihzZXJ2ZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAoc2VydmVyLmhvc3RuYW1lLmVuZHNXaXRoKCcuYjJjbG9naW4uY29tJykgJiZcbiAgICAgICAgKCFvcHRpb25zPy5hbGdvcml0aG0gfHwgb3B0aW9ucy5hbGdvcml0aG0gPT09ICdvaWRjJykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkeW5hbWljQ2xpZW50UmVnaXN0cmF0aW9uKHNlcnZlciwgbWV0YWRhdGEsIGNsaWVudEF1dGhlbnRpY2F0aW9uLCBvcHRpb25zKSB7XG4gICAgbGV0IGFzO1xuICAgIGlmIChvcHRpb25zPy5mbGFnID09PSByZXRyeSkge1xuICAgICAgICBhcyA9IG9wdGlvbnMuYXM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhcyA9IGF3YWl0IHBlcmZvcm1EaXNjb3Zlcnkoc2VydmVyLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3QgY2xvY2tTa2V3ID0gbWV0YWRhdGFbb2F1dGguY2xvY2tTa2V3XSA/PyAwO1xuICAgIGNvbnN0IGNsb2NrVG9sZXJhbmNlID0gbWV0YWRhdGFbb2F1dGguY2xvY2tUb2xlcmFuY2VdID8/IDMwO1xuICAgIG1ldGFkYXRhID0gc3RydWN0dXJlZENsb25lKG1ldGFkYXRhKTtcbiAgICBjb25zdCB0aW1lb3V0ID0gb3B0aW9ucz8udGltZW91dCA/PyAzMDtcbiAgICBjb25zdCBzaWduYWwgPSBBYm9ydFNpZ25hbC50aW1lb3V0KHRpbWVvdXQgKiAxMDAwKTtcbiAgICBsZXQgcmVnaXN0ZXJlZDtcbiAgICB0cnkge1xuICAgICAgICByZWdpc3RlcmVkID0gYXdhaXQgb2F1dGhcbiAgICAgICAgICAgIC5keW5hbWljQ2xpZW50UmVnaXN0cmF0aW9uUmVxdWVzdChhcywgbWV0YWRhdGEsIHtcbiAgICAgICAgICAgIGluaXRpYWxBY2Nlc3NUb2tlbjogb3B0aW9ucz8uaW5pdGlhbEFjY2Vzc1Rva2VuLFxuICAgICAgICAgICAgRFBvUDogb3B0aW9ucz8uRFBvUCxcbiAgICAgICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKGhlYWRlcnMpLFxuICAgICAgICAgICAgW29hdXRoLmN1c3RvbUZldGNoXTogb3B0aW9ucz8uW2N1c3RvbUZldGNoXSxcbiAgICAgICAgICAgIFtvYXV0aC5hbGxvd0luc2VjdXJlUmVxdWVzdHNdOiBvcHRpb25zPy5leGVjdXRlPy5pbmNsdWRlcyhhbGxvd0luc2VjdXJlUmVxdWVzdHMpLFxuICAgICAgICAgICAgc2lnbmFsLFxuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4ob2F1dGgucHJvY2Vzc0R5bmFtaWNDbGllbnRSZWdpc3RyYXRpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKHJldHJ5YWJsZShlcnIsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZHluYW1pY0NsaWVudFJlZ2lzdHJhdGlvbihzZXJ2ZXIsIG1ldGFkYXRhLCBjbGllbnRBdXRoZW50aWNhdGlvbiwge1xuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgZmxhZzogcmV0cnksXG4gICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvckhhbmRsZXIoZXJyKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJlZFtvYXV0aC5jbG9ja1NrZXddID0gY2xvY2tTa2V3O1xuICAgIHJlZ2lzdGVyZWRbb2F1dGguY2xvY2tUb2xlcmFuY2VdID0gY2xvY2tUb2xlcmFuY2U7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgQ29uZmlndXJhdGlvbihhcywgcmVnaXN0ZXJlZC5jbGllbnRfaWQsIHJlZ2lzdGVyZWQsIGNsaWVudEF1dGhlbnRpY2F0aW9uKTtcbiAgICBsZXQgaW50ZXJuYWxzID0gaW50KGluc3RhbmNlKTtcbiAgICBpZiAob3B0aW9ucz8uW2N1c3RvbUZldGNoXSkge1xuICAgICAgICBpbnRlcm5hbHMuZmV0Y2ggPSBvcHRpb25zW2N1c3RvbUZldGNoXTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnM/LnRpbWVvdXQpIHtcbiAgICAgICAgaW50ZXJuYWxzLnRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQ7XG4gICAgfVxuICAgIGlmIChvcHRpb25zPy5leGVjdXRlKSB7XG4gICAgICAgIGZvciAoY29uc3QgZXh0ZW5zaW9uIG9mIG9wdGlvbnMuZXhlY3V0ZSkge1xuICAgICAgICAgICAgZXh0ZW5zaW9uKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2U7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGlzY292ZXJ5KHNlcnZlciwgY2xpZW50SWQsIG1ldGFkYXRhLCBjbGllbnRBdXRoZW50aWNhdGlvbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IGFzID0gYXdhaXQgcGVyZm9ybURpc2NvdmVyeShzZXJ2ZXIsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IENvbmZpZ3VyYXRpb24oYXMsIGNsaWVudElkLCBtZXRhZGF0YSwgY2xpZW50QXV0aGVudGljYXRpb24pO1xuICAgIGxldCBpbnRlcm5hbHMgPSBpbnQoaW5zdGFuY2UpO1xuICAgIGlmIChvcHRpb25zPy5bY3VzdG9tRmV0Y2hdKSB7XG4gICAgICAgIGludGVybmFscy5mZXRjaCA9IG9wdGlvbnNbY3VzdG9tRmV0Y2hdO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucz8udGltZW91dCkge1xuICAgICAgICBpbnRlcm5hbHMudGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnM/LmV4ZWN1dGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBleHRlbnNpb24gb2Ygb3B0aW9ucy5leGVjdXRlKSB7XG4gICAgICAgICAgICBleHRlbnNpb24oaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBlcmZvcm1EaXNjb3Zlcnkoc2VydmVyLCBvcHRpb25zKSB7XG4gICAgaWYgKCEoc2VydmVyIGluc3RhbmNlb2YgVVJMKSkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJzZXJ2ZXJcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIFVSTCcsIEVSUl9JTlZBTElEX0FSR19UWVBFKTtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZSA9ICFzZXJ2ZXIuaHJlZi5pbmNsdWRlcygnLy53ZWxsLWtub3duLycpO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBvcHRpb25zPy50aW1lb3V0ID8/IDMwO1xuICAgIGNvbnN0IHNpZ25hbCA9IEFib3J0U2lnbmFsLnRpbWVvdXQodGltZW91dCAqIDEwMDApO1xuICAgIGNvbnN0IGFzID0gYXdhaXQgKHJlc29sdmVcbiAgICAgICAgPyBvYXV0aC5kaXNjb3ZlcnlSZXF1ZXN0KHNlcnZlciwge1xuICAgICAgICAgICAgYWxnb3JpdGhtOiBvcHRpb25zPy5hbGdvcml0aG0sXG4gICAgICAgICAgICBbb2F1dGguY3VzdG9tRmV0Y2hdOiBvcHRpb25zPy5bY3VzdG9tRmV0Y2hdLFxuICAgICAgICAgICAgW29hdXRoLmFsbG93SW5zZWN1cmVSZXF1ZXN0c106IG9wdGlvbnM/LmV4ZWN1dGU/LmluY2x1ZGVzKGFsbG93SW5zZWN1cmVSZXF1ZXN0cyksXG4gICAgICAgICAgICBzaWduYWwsXG4gICAgICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhoZWFkZXJzKSxcbiAgICAgICAgfSlcbiAgICAgICAgOiAob3B0aW9ucz8uW2N1c3RvbUZldGNoXSB8fCBmZXRjaCkoKCgpID0+IHtcbiAgICAgICAgICAgIG9hdXRoLmNoZWNrUHJvdG9jb2woc2VydmVyLCBvcHRpb25zPy5leGVjdXRlPy5pbmNsdWRlcyhhbGxvd0luc2VjdXJlUmVxdWVzdHMpID8gZmFsc2UgOiB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBzZXJ2ZXIuaHJlZjtcbiAgICAgICAgfSkoKSwge1xuICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKG5ldyBIZWFkZXJzKHsgYWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsIC4uLmhlYWRlcnMgfSkuZW50cmllcygpKSxcbiAgICAgICAgICAgIGJvZHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICByZWRpcmVjdDogJ21hbnVhbCcsXG4gICAgICAgICAgICBzaWduYWwsXG4gICAgICAgIH0pKVxuICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IG9hdXRoLnByb2Nlc3NEaXNjb3ZlcnlSZXNwb25zZShvYXV0aC5fbm9kaXNjb3ZlcnljaGVjaywgcmVzcG9uc2UpKVxuICAgICAgICAuY2F0Y2goZXJyb3JIYW5kbGVyKTtcbiAgICBpZiAocmVzb2x2ZSAmJiBuZXcgVVJMKGFzLmlzc3VlcikuaHJlZiAhPT0gc2VydmVyLmhyZWYpIHtcbiAgICAgICAgaGFuZGxlRW50cmFJZChzZXJ2ZXIsIGFzLCBvcHRpb25zKSB8fFxuICAgICAgICAgICAgaGFuZGxlQjJDbG9naW4oc2VydmVyLCBvcHRpb25zKSB8fFxuICAgICAgICAgICAgKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ2xpZW50RXJyb3IoJ2Rpc2NvdmVyZWQgbWV0YWRhdGEgaXNzdWVyIGRvZXMgbm90IG1hdGNoIHRoZSBleHBlY3RlZCBpc3N1ZXInLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IG9hdXRoLkpTT05fQVRUUklCVVRFX0NPTVBBUklTT04sXG4gICAgICAgICAgICAgICAgICAgIGNhdXNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogc2VydmVyLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZTogJ2lzc3VlcicsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSgpO1xuICAgIH1cbiAgICByZXR1cm4gYXM7XG59XG5mdW5jdGlvbiBpc1JzYU9hZXAoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQubmFtZSA9PT0gJ1JTQS1PQUVQJztcbn1cbmZ1bmN0aW9uIGlzRWNkaChpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5uYW1lID09PSAnRUNESCc7XG59XG5jb25zdCBlY2RoRXMgPSAnRUNESC1FUyc7XG5jb25zdCBlY2RoRXNBMTI4S3cgPSAnRUNESC1FUytBMTI4S1cnO1xuY29uc3QgZWNkaEVzQTE5Mkt3ID0gJ0VDREgtRVMrQTE5MktXJztcbmNvbnN0IGVjZGhFc0EyNTZLdyA9ICdFQ0RILUVTK0EyNTZLVyc7XG5mdW5jdGlvbiBjaGVja0VjZGhBbGcoYWxncywgYWxnLCBwaykge1xuICAgIHN3aXRjaCAoYWxnKSB7XG4gICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgYWxncy5hZGQoZWNkaEVzKTtcbiAgICAgICAgICAgIGFsZ3MuYWRkKGVjZGhFc0ExMjhLdyk7XG4gICAgICAgICAgICBhbGdzLmFkZChlY2RoRXNBMTkyS3cpO1xuICAgICAgICAgICAgYWxncy5hZGQoZWNkaEVzQTI1Nkt3KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGVjZGhFczpcbiAgICAgICAgY2FzZSBlY2RoRXNBMTI4S3c6XG4gICAgICAgIGNhc2UgZWNkaEVzQTE5Mkt3OlxuICAgICAgICBjYXNlIGVjZGhFc0EyNTZLdzpcbiAgICAgICAgICAgIGFsZ3MuYWRkKGFsZyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdpbnZhbGlkIGtleSBhbGcnLCBFUlJfSU5WQUxJRF9BUkdfVkFMVUUsIHsgcGsgfSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZURlY3J5cHRpbmdSZXNwb25zZXMoY29uZmlnLCBjb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobXMgPSBbXG4gICAgJ0ExMjhHQ00nLFxuICAgICdBMTkyR0NNJyxcbiAgICAnQTI1NkdDTScsXG4gICAgJ0ExMjhDQkMtSFMyNTYnLFxuICAgICdBMTkyQ0JDLUhTMzg0JyxcbiAgICAnQTI1NkNCQy1IUzUxMicsXG5dLCAuLi5rZXlzKSB7XG4gICAgaWYgKGludChjb25maWcpLmRlY3J5cHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmFibGVEZWNyeXB0aW5nUmVzcG9uc2VzIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhIGdpdmVuIENvbmZpZ3VyYXRpb24gaW5zdGFuY2Ugb25jZScpO1xuICAgIH1cbiAgICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ25vIGtleXMgd2VyZSBwcm92aWRlZCcsIEVSUl9JTlZBTElEX0FSR19WQUxVRSk7XG4gICAgfVxuICAgIGNvbnN0IGFsZ3MgPSBuZXcgU2V0KCk7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IFtdO1xuICAgIGZvciAoY29uc3QgcGsgb2Yga2V5cykge1xuICAgICAgICBsZXQga2V5O1xuICAgICAgICBpZiAoJ2tleScgaW4gcGspIHtcbiAgICAgICAgICAgIGtleSA9IHsga2V5OiBway5rZXkgfTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGsuYWxnID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICBrZXkuYWxnID0gcGsuYWxnO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBway5raWQgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIGtleS5raWQgPSBway5raWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBrZXkgPSB7IGtleTogcGsgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5LmtleS50eXBlICE9PSAncHJpdmF0ZScpIHtcbiAgICAgICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdvbmx5IHByaXZhdGUga2V5cyBtdXN0IGJlIHByb3ZpZGVkJywgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNSc2FPYWVwKGtleS5rZXkuYWxnb3JpdGhtKSkge1xuICAgICAgICAgICAgc3dpdGNoIChrZXkua2V5LmFsZ29yaXRobS5oYXNoLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdTSEEtMSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnU0hBLTI1Nic6XG4gICAgICAgICAgICAgICAgY2FzZSAnU0hBLTM4NCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnU0hBLTUxMic6IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFsZyA9ICdSU0EtT0FFUCc7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaGE7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoc2hhID0gcGFyc2VJbnQoa2V5LmtleS5hbGdvcml0aG0uaGFzaC5uYW1lLnNsaWNlKC0zKSwgMTApKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxnID0gYCR7YWxnfS0ke3NoYX1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGtleS5hbGcgfHw9IGFsZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsZyAhPT0ga2V5LmFsZylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdpbnZhbGlkIGtleSBhbGcnLCBFUlJfSU5WQUxJRF9BUkdfVkFMVUUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwayxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhbGdzLmFkZChrZXkuYWxnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdvbmx5IFNIQS01MTIsIFNIQS0zODQsIFNIQS0yNTYsIGFuZCBTSEEtMSBSU0EtT0FFUCBrZXlzIGFyZSBzdXBwb3J0ZWQnLCBFUlJfSU5WQUxJRF9BUkdfVkFMVUUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRWNkaChrZXkua2V5LmFsZ29yaXRobSkpIHtcbiAgICAgICAgICAgIGlmIChrZXkua2V5LmFsZ29yaXRobS5uYW1lZEN1cnZlICE9PSAnUC0yNTYnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ09ubHkgUC0yNTYgRUNESCBrZXlzIGFyZSBzdXBwb3J0ZWQnLCBFUlJfSU5WQUxJRF9BUkdfVkFMVUUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hlY2tFY2RoQWxnKGFsZ3MsIGtleS5hbGcsIHBrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkua2V5LmFsZ29yaXRobS5uYW1lID09PSAnWDI1NTE5Jykge1xuICAgICAgICAgICAgY2hlY2tFY2RoQWxnKGFsZ3MsIGtleS5hbGcsIHBrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdvbmx5IFJTQS1PQUVQLCBFQ0RILCBvciBYMjU1MTkga2V5cyBhcmUgc3VwcG9ydGVkJywgRVJSX0lOVkFMSURfQVJHX1ZBTFVFKTtcbiAgICAgICAgfVxuICAgICAgICBub3JtYWxpemVkLnB1c2goa2V5KTtcbiAgICB9XG4gICAgaW50KGNvbmZpZykuZGVjcnlwdCA9IGFzeW5jIChqd2UpID0+IGRlY3J5cHQobm9ybWFsaXplZCwgandlLCBjb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobXMsIFsuLi5hbGdzXSkuY2F0Y2goZXJyb3JIYW5kbGVyKTtcbn1cbmZ1bmN0aW9uIGNoZWNrQ3J5cHRvS2V5KGtleSwgYWxnLCBlcGspIHtcbiAgICBpZiAoYWxnLnN0YXJ0c1dpdGgoJ1JTQS1PQUVQJykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChhbGcuc3RhcnRzV2l0aCgnRUNESC1FUycpKSB7XG4gICAgICAgIGlmIChrZXkuYWxnb3JpdGhtLm5hbWUgIT09ICdFQ0RIJyAmJiBrZXkuYWxnb3JpdGhtLm5hbWUgIT09ICdYMjU1MTknKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleS5hbGdvcml0aG0ubmFtZSA9PT0gJ0VDREgnKSB7XG4gICAgICAgICAgICByZXR1cm4gZXBrPy5jcnYgPT09IGtleS5hbGdvcml0aG0ubmFtZWRDdXJ2ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5LmFsZ29yaXRobS5uYW1lID09PSAnWDI1NTE5Jykge1xuICAgICAgICAgICAgcmV0dXJuIGVwaz8uY3J2ID09PSAnWDI1NTE5JztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZWxlY3RDcnlwdG9LZXlGb3JEZWNyeXB0aW9uKGtleXMsIGFsZywga2lkLCBlcGspIHtcbiAgICBjb25zdCB7IDA6IGtleSwgbGVuZ3RoIH0gPSBrZXlzLmZpbHRlcigoa2V5KSA9PiB7XG4gICAgICAgIGlmIChraWQgIT09IGtleS5raWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5LmFsZyAmJiBhbGcgIT09IGtleS5hbGcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hlY2tDcnlwdG9LZXkoa2V5LmtleSwgYWxnLCBlcGspO1xuICAgIH0pO1xuICAgIGlmICgha2V5KSB7XG4gICAgICAgIHRocm93IGUoJ25vIGFwcGxpY2FibGUgZGVjcnlwdGlvbiBrZXkgc2VsZWN0ZWQnLCB1bmRlZmluZWQsICdPQVVUSF9ERUNSWVBUSU9OX0ZBSUxFRCcpO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IGUoJ211bHRpcGxlIGFwcGxpY2FibGUgZGVjcnlwdGlvbiBrZXlzIHNlbGVjdGVkJywgdW5kZWZpbmVkLCAnT0FVVEhfREVDUllQVElPTl9GQUlMRUQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleS5rZXk7XG59XG5hc3luYyBmdW5jdGlvbiBkZWNyeXB0KGtleXMsIGp3ZSwgY29udGVudEVuY3J5cHRpb25BbGdvcml0aG1zLCBrZXlNYW5hZ2VtZW50QWxnb3JpdGhtcykge1xuICAgIHJldHVybiBkZWNvZGVyLmRlY29kZSgoYXdhaXQgY29tcGFjdERlY3J5cHQoandlLCAoaGVhZGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHsga2lkLCBhbGcsIGVwayB9ID0gaGVhZGVyO1xuICAgICAgICByZXR1cm4gc2VsZWN0Q3J5cHRvS2V5Rm9yRGVjcnlwdGlvbihrZXlzLCBhbGcsIGtpZCwgZXBrKTtcbiAgICB9LCB7IGtleU1hbmFnZW1lbnRBbGdvcml0aG1zLCBjb250ZW50RW5jcnlwdGlvbkFsZ29yaXRobXMgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgSk9TRUVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBlKCdkZWNyeXB0aW9uIGZhaWxlZCcsIGVyciwgJ09BVVRIX0RFQ1JZUFRJT05fRkFJTEVEJyk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3JIYW5kbGVyKGVycik7XG4gICAgfSkpLnBsYWludGV4dCk7XG59XG5mdW5jdGlvbiBnZXRTZXJ2ZXJIZWxwZXJzKG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3VwcG9ydHNQS0NFOiB7XG4gICAgICAgICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICAgICAgICB2YWx1ZShtZXRob2QgPSAnUzI1NicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKG1ldGFkYXRhLmNvZGVfY2hhbGxlbmdlX21ldGhvZHNfc3VwcG9ydGVkPy5pbmNsdWRlcyhtZXRob2QpID09PSB0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFkZFNlcnZlckhlbHBlcnMobWV0YWRhdGEpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhtZXRhZGF0YSwgZ2V0U2VydmVySGVscGVycyhtZXRhZGF0YSkpO1xufVxuY29uc3Qga0VudHJhSWQgPSBTeW1ib2woKTtcbmV4cG9ydCBjbGFzcyBDb25maWd1cmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2ZXIsIGNsaWVudElkLCBtZXRhZGF0YSwgY2xpZW50QXV0aGVudGljYXRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGllbnRJZCAhPT0gJ3N0cmluZycgfHwgIWNsaWVudElkLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wiY2xpZW50SWRcIiBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycsIEVSUl9JTlZBTElEX0FSR19UWVBFKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG1ldGFkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbWV0YWRhdGEgPSB7IGNsaWVudF9zZWNyZXQ6IG1ldGFkYXRhIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGFkYXRhPy5jbGllbnRfaWQgIT09IHVuZGVmaW5lZCAmJiBjbGllbnRJZCAhPT0gbWV0YWRhdGEuY2xpZW50X2lkKSB7XG4gICAgICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJjbGllbnRJZFwiIGFuZCBcIm1ldGFkYXRhLmNsaWVudF9pZFwiIG11c3QgYmUgdGhlIHNhbWUnLCBFUlJfSU5WQUxJRF9BUkdfVkFMVUUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IHtcbiAgICAgICAgICAgIC4uLnN0cnVjdHVyZWRDbG9uZShtZXRhZGF0YSksXG4gICAgICAgICAgICBjbGllbnRfaWQ6IGNsaWVudElkLFxuICAgICAgICB9O1xuICAgICAgICBjbGllbnRbb2F1dGguY2xvY2tTa2V3XSA9IG1ldGFkYXRhPy5bb2F1dGguY2xvY2tTa2V3XSA/PyAwO1xuICAgICAgICBjbGllbnRbb2F1dGguY2xvY2tUb2xlcmFuY2VdID0gbWV0YWRhdGE/LltvYXV0aC5jbG9ja1RvbGVyYW5jZV0gPz8gMzA7XG4gICAgICAgIGxldCBhdXRoO1xuICAgICAgICBpZiAoY2xpZW50QXV0aGVudGljYXRpb24pIHtcbiAgICAgICAgICAgIGF1dGggPSBjbGllbnRBdXRoZW50aWNhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2xpZW50LmNsaWVudF9zZWNyZXQgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgY2xpZW50LmNsaWVudF9zZWNyZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXV0aCA9IENsaWVudFNlY3JldFBvc3QoY2xpZW50LmNsaWVudF9zZWNyZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXV0aCA9IE5vbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgYyA9IE9iamVjdC5mcmVlemUoY2xpZW50KTtcbiAgICAgICAgY29uc3QgY2xvbmUgPSBzdHJ1Y3R1cmVkQ2xvbmUoc2VydmVyKTtcbiAgICAgICAgaWYgKGtFbnRyYUlkIGluIHNlcnZlcikge1xuICAgICAgICAgICAgY2xvbmVbb2F1dGguX2V4cGVjdGVkSXNzdWVyXSA9ICh7IGNsYWltczogeyB0aWQgfSB9KSA9PiBzZXJ2ZXIuaXNzdWVyLnJlcGxhY2UoJ3t0ZW5hbnRpZH0nLCB0aWQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhcyA9IE9iamVjdC5mcmVlemUoY2xvbmUpO1xuICAgICAgICBwcm9wcyB8fD0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgcHJvcHMuc2V0KHRoaXMsIHtcbiAgICAgICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIGF1dGgsXG4gICAgICAgICAgICB0bHNPbmx5OiB0cnVlLFxuICAgICAgICAgICAgandrc0NhY2hlOiB7fSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlcnZlck1ldGFkYXRhKCkge1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHN0cnVjdHVyZWRDbG9uZShpbnQodGhpcykuYXMpO1xuICAgICAgICBhZGRTZXJ2ZXJIZWxwZXJzKG1ldGFkYXRhKTtcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgIH1cbiAgICBjbGllbnRNZXRhZGF0YSgpIHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBzdHJ1Y3R1cmVkQ2xvbmUoaW50KHRoaXMpLmMpO1xuICAgICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgfVxuICAgIGdldCB0aW1lb3V0KCkge1xuICAgICAgICByZXR1cm4gaW50KHRoaXMpLnRpbWVvdXQ7XG4gICAgfVxuICAgIHNldCB0aW1lb3V0KHZhbHVlKSB7XG4gICAgICAgIGludCh0aGlzKS50aW1lb3V0ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBbY3VzdG9tRmV0Y2hdKCkge1xuICAgICAgICByZXR1cm4gaW50KHRoaXMpLmZldGNoO1xuICAgIH1cbiAgICBzZXQgW2N1c3RvbUZldGNoXSh2YWx1ZSkge1xuICAgICAgICBpbnQodGhpcykuZmV0Y2ggPSB2YWx1ZTtcbiAgICB9XG59XG5PYmplY3QuZnJlZXplKENvbmZpZ3VyYXRpb24ucHJvdG90eXBlKTtcbmZ1bmN0aW9uIGdldEhlbHBlcnMocmVzcG9uc2UpIHtcbiAgICBsZXQgZXhwID0gdW5kZWZpbmVkO1xuICAgIGlmIChyZXNwb25zZS5leHBpcmVzX2luICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgbm93LnNldFNlY29uZHMobm93LmdldFNlY29uZHMoKSArIHJlc3BvbnNlLmV4cGlyZXNfaW4pO1xuICAgICAgICBleHAgPSBub3cuZ2V0VGltZSgpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBleHBpcmVzSW46IHtcbiAgICAgICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgICAgIHZhbHVlKCkge1xuICAgICAgICAgICAgICAgIGlmIChleHApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cCA+IG5vdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKGV4cCAtIG5vdykgLyAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGNsYWltczoge1xuICAgICAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICAgICAgdmFsdWUoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9hdXRoLmdldFZhbGlkYXRlZElkVG9rZW5DbGFpbXModGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBhZGRIZWxwZXJzKHJlc3BvbnNlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocmVzcG9uc2UsIGdldEhlbHBlcnMocmVzcG9uc2UpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXREUG9QSGFuZGxlKGNvbmZpZywga2V5UGFpciwgb3B0aW9ucykge1xuICAgIGNoZWNrQ29uZmlnKGNvbmZpZyk7XG4gICAgcmV0dXJuIG9hdXRoLkRQb1AoaW50KGNvbmZpZykuYywga2V5UGFpciwgb3B0aW9ucyk7XG59XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVSZXRyeUFmdGVyKHJlc3BvbnNlLCBjdXJyZW50SW50ZXJ2YWwsIHNpZ25hbCwgdGhyb3dJZkludmFsaWQgPSBmYWxzZSkge1xuICAgIGNvbnN0IHJldHJ5QWZ0ZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldCgncmV0cnktYWZ0ZXInKT8udHJpbSgpO1xuICAgIGlmIChyZXRyeUFmdGVyID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgZGVsYXlTZWNvbmRzO1xuICAgIGlmICgvXlxcZCskLy50ZXN0KHJldHJ5QWZ0ZXIpKSB7XG4gICAgICAgIGRlbGF5U2Vjb25kcyA9IHBhcnNlSW50KHJldHJ5QWZ0ZXIsIDEwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHJldHJ5RGF0ZSA9IG5ldyBEYXRlKHJldHJ5QWZ0ZXIpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHJldHJ5RGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgZGVsYXlNcyA9IHJldHJ5RGF0ZS5nZXRUaW1lKCkgLSBub3cuZ2V0VGltZSgpO1xuICAgICAgICAgICAgaWYgKGRlbGF5TXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgZGVsYXlTZWNvbmRzID0gTWF0aC5jZWlsKGRlbGF5TXMgLyAxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhyb3dJZkludmFsaWQgJiYgIU51bWJlci5pc0Zpbml0ZShkZWxheVNlY29uZHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBvYXV0aC5PcGVyYXRpb25Qcm9jZXNzaW5nRXJyb3IoJ2ludmFsaWQgUmV0cnktQWZ0ZXIgaGVhZGVyIHZhbHVlJywgeyBjYXVzZTogcmVzcG9uc2UgfSk7XG4gICAgfVxuICAgIGlmIChkZWxheVNlY29uZHMgPiBjdXJyZW50SW50ZXJ2YWwpIHtcbiAgICAgICAgYXdhaXQgd2FpdChkZWxheVNlY29uZHMgLSBjdXJyZW50SW50ZXJ2YWwsIHNpZ25hbCk7XG4gICAgfVxufVxuZnVuY3Rpb24gd2FpdChkdXJhdGlvbiwgc2lnbmFsKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3Qgd2FpdFN0ZXAgPSAocmVtYWluaW5nKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHNpZ25hbC50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZW1haW5pbmcgPD0gMCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50V2FpdCA9IE1hdGgubWluKHJlbWFpbmluZywgNSk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHdhaXRTdGVwKHJlbWFpbmluZyAtIGN1cnJlbnRXYWl0KSwgY3VycmVudFdhaXQgKiAxMDAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgd2FpdFN0ZXAoZHVyYXRpb24pO1xuICAgIH0pO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBvbGxEZXZpY2VBdXRob3JpemF0aW9uR3JhbnQoY29uZmlnLCBkZXZpY2VBdXRob3JpemF0aW9uUmVzcG9uc2UsIHBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICBjaGVja0NvbmZpZyhjb25maWcpO1xuICAgIHBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtZXRlcnMpO1xuICAgIGxldCBpbnRlcnZhbCA9IGRldmljZUF1dGhvcml6YXRpb25SZXNwb25zZS5pbnRlcnZhbCA/PyA1O1xuICAgIGNvbnN0IHBvbGxpbmdTaWduYWwgPSBvcHRpb25zPy5zaWduYWwgPz9cbiAgICAgICAgQWJvcnRTaWduYWwudGltZW91dChkZXZpY2VBdXRob3JpemF0aW9uUmVzcG9uc2UuZXhwaXJlc19pbiAqIDEwMDApO1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHdhaXQoaW50ZXJ2YWwsIHBvbGxpbmdTaWduYWwpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVycm9ySGFuZGxlcihlcnIpO1xuICAgIH1cbiAgICBjb25zdCB7IGFzLCBjLCBhdXRoLCBmZXRjaCwgdGxzT25seSwgbm9uUmVwdWRpYXRpb24sIHRpbWVvdXQsIGRlY3J5cHQgfSA9IGludChjb25maWcpO1xuICAgIGNvbnN0IHJldHJ5UG9sbCA9ICh1cGRhdGVkSW50ZXJ2YWwsIGZsYWcpID0+IHBvbGxEZXZpY2VBdXRob3JpemF0aW9uR3JhbnQoY29uZmlnLCB7XG4gICAgICAgIC4uLmRldmljZUF1dGhvcml6YXRpb25SZXNwb25zZSxcbiAgICAgICAgaW50ZXJ2YWw6IHVwZGF0ZWRJbnRlcnZhbCxcbiAgICB9LCBwYXJhbWV0ZXJzLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHNpZ25hbDogcG9sbGluZ1NpZ25hbCxcbiAgICAgICAgZmxhZyxcbiAgICB9KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG9hdXRoXG4gICAgICAgIC5kZXZpY2VDb2RlR3JhbnRSZXF1ZXN0KGFzLCBjLCBhdXRoLCBkZXZpY2VBdXRob3JpemF0aW9uUmVzcG9uc2UuZGV2aWNlX2NvZGUsIHtcbiAgICAgICAgW29hdXRoLmN1c3RvbUZldGNoXTogZmV0Y2gsXG4gICAgICAgIFtvYXV0aC5hbGxvd0luc2VjdXJlUmVxdWVzdHNdOiAhdGxzT25seSxcbiAgICAgICAgYWRkaXRpb25hbFBhcmFtZXRlcnM6IHBhcmFtZXRlcnMsXG4gICAgICAgIERQb1A6IG9wdGlvbnM/LkRQb1AsXG4gICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKGhlYWRlcnMpLFxuICAgICAgICBzaWduYWw6IHBvbGxpbmdTaWduYWwuYWJvcnRlZCA/IHBvbGxpbmdTaWduYWwgOiBzaWduYWwodGltZW91dCksXG4gICAgfSlcbiAgICAgICAgLmNhdGNoKGVycm9ySGFuZGxlcik7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNTAzICYmIHJlc3BvbnNlLmhlYWRlcnMuaGFzKCdyZXRyeS1hZnRlcicpKSB7XG4gICAgICAgIGF3YWl0IGhhbmRsZVJldHJ5QWZ0ZXIocmVzcG9uc2UsIGludGVydmFsLCBwb2xsaW5nU2lnbmFsLCB0cnVlKTtcbiAgICAgICAgYXdhaXQgcmVzcG9uc2UuYm9keT8uY2FuY2VsKCk7XG4gICAgICAgIHJldHVybiByZXRyeVBvbGwoaW50ZXJ2YWwpO1xuICAgIH1cbiAgICBjb25zdCBwID0gb2F1dGgucHJvY2Vzc0RldmljZUNvZGVSZXNwb25zZShhcywgYywgcmVzcG9uc2UsIHtcbiAgICAgICAgW29hdXRoLmp3ZURlY3J5cHRdOiBkZWNyeXB0LFxuICAgIH0pO1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgcDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAocmV0cnlhYmxlKGVyciwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybiByZXRyeVBvbGwoaW50ZXJ2YWwsIHJldHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2Ygb2F1dGguUmVzcG9uc2VCb2R5RXJyb3IpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZXJyLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2xvd19kb3duJzpcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwgKz0gNTtcbiAgICAgICAgICAgICAgICBjYXNlICdhdXRob3JpemF0aW9uX3BlbmRpbmcnOlxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVSZXRyeUFmdGVyKGVyci5yZXNwb25zZSwgaW50ZXJ2YWwsIHBvbGxpbmdTaWduYWwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0cnlQb2xsKGludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlcnJvckhhbmRsZXIoZXJyKTtcbiAgICB9XG4gICAgcmVzdWx0LmlkX3Rva2VuICYmIChhd2FpdCBub25SZXB1ZGlhdGlvbj8uKHJlc3BvbnNlKSk7XG4gICAgYWRkSGVscGVycyhyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5pdGlhdGVEZXZpY2VBdXRob3JpemF0aW9uKGNvbmZpZywgcGFyYW1ldGVycykge1xuICAgIGNoZWNrQ29uZmlnKGNvbmZpZyk7XG4gICAgY29uc3QgeyBhcywgYywgYXV0aCwgZmV0Y2gsIHRsc09ubHksIHRpbWVvdXQgfSA9IGludChjb25maWcpO1xuICAgIHJldHVybiBvYXV0aFxuICAgICAgICAuZGV2aWNlQXV0aG9yaXphdGlvblJlcXVlc3QoYXMsIGMsIGF1dGgsIHBhcmFtZXRlcnMsIHtcbiAgICAgICAgW29hdXRoLmN1c3RvbUZldGNoXTogZmV0Y2gsXG4gICAgICAgIFtvYXV0aC5hbGxvd0luc2VjdXJlUmVxdWVzdHNdOiAhdGxzT25seSxcbiAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoaGVhZGVycyksXG4gICAgICAgIHNpZ25hbDogc2lnbmFsKHRpbWVvdXQpLFxuICAgIH0pXG4gICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4gb2F1dGgucHJvY2Vzc0RldmljZUF1dGhvcml6YXRpb25SZXNwb25zZShhcywgYywgcmVzcG9uc2UpKVxuICAgICAgICAuY2F0Y2goZXJyb3JIYW5kbGVyKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0aWF0ZUJhY2tjaGFubmVsQXV0aGVudGljYXRpb24oY29uZmlnLCBwYXJhbWV0ZXJzKSB7XG4gICAgY2hlY2tDb25maWcoY29uZmlnKTtcbiAgICBjb25zdCB7IGFzLCBjLCBhdXRoLCBmZXRjaCwgdGxzT25seSwgdGltZW91dCB9ID0gaW50KGNvbmZpZyk7XG4gICAgcmV0dXJuIG9hdXRoXG4gICAgICAgIC5iYWNrY2hhbm5lbEF1dGhlbnRpY2F0aW9uUmVxdWVzdChhcywgYywgYXV0aCwgcGFyYW1ldGVycywge1xuICAgICAgICBbb2F1dGguY3VzdG9tRmV0Y2hdOiBmZXRjaCxcbiAgICAgICAgW29hdXRoLmFsbG93SW5zZWN1cmVSZXF1ZXN0c106ICF0bHNPbmx5LFxuICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhoZWFkZXJzKSxcbiAgICAgICAgc2lnbmFsOiBzaWduYWwodGltZW91dCksXG4gICAgfSlcbiAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiBvYXV0aC5wcm9jZXNzQmFja2NoYW5uZWxBdXRoZW50aWNhdGlvblJlc3BvbnNlKGFzLCBjLCByZXNwb25zZSkpXG4gICAgICAgIC5jYXRjaChlcnJvckhhbmRsZXIpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBvbGxCYWNrY2hhbm5lbEF1dGhlbnRpY2F0aW9uR3JhbnQoY29uZmlnLCBiYWNrY2hhbm5lbEF1dGhlbnRpY2F0aW9uUmVzcG9uc2UsIHBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICBjaGVja0NvbmZpZyhjb25maWcpO1xuICAgIHBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtZXRlcnMpO1xuICAgIGxldCBpbnRlcnZhbCA9IGJhY2tjaGFubmVsQXV0aGVudGljYXRpb25SZXNwb25zZS5pbnRlcnZhbCA/PyA1O1xuICAgIGNvbnN0IHBvbGxpbmdTaWduYWwgPSBvcHRpb25zPy5zaWduYWwgPz9cbiAgICAgICAgQWJvcnRTaWduYWwudGltZW91dChiYWNrY2hhbm5lbEF1dGhlbnRpY2F0aW9uUmVzcG9uc2UuZXhwaXJlc19pbiAqIDEwMDApO1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHdhaXQoaW50ZXJ2YWwsIHBvbGxpbmdTaWduYWwpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGVycm9ySGFuZGxlcihlcnIpO1xuICAgIH1cbiAgICBjb25zdCB7IGFzLCBjLCBhdXRoLCBmZXRjaCwgdGxzT25seSwgbm9uUmVwdWRpYXRpb24sIHRpbWVvdXQsIGRlY3J5cHQgfSA9IGludChjb25maWcpO1xuICAgIGNvbnN0IHJldHJ5UG9sbCA9ICh1cGRhdGVkSW50ZXJ2YWwsIGZsYWcpID0+IHBvbGxCYWNrY2hhbm5lbEF1dGhlbnRpY2F0aW9uR3JhbnQoY29uZmlnLCB7XG4gICAgICAgIC4uLmJhY2tjaGFubmVsQXV0aGVudGljYXRpb25SZXNwb25zZSxcbiAgICAgICAgaW50ZXJ2YWw6IHVwZGF0ZWRJbnRlcnZhbCxcbiAgICB9LCBwYXJhbWV0ZXJzLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHNpZ25hbDogcG9sbGluZ1NpZ25hbCxcbiAgICAgICAgZmxhZyxcbiAgICB9KTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG9hdXRoXG4gICAgICAgIC5iYWNrY2hhbm5lbEF1dGhlbnRpY2F0aW9uR3JhbnRSZXF1ZXN0KGFzLCBjLCBhdXRoLCBiYWNrY2hhbm5lbEF1dGhlbnRpY2F0aW9uUmVzcG9uc2UuYXV0aF9yZXFfaWQsIHtcbiAgICAgICAgW29hdXRoLmN1c3RvbUZldGNoXTogZmV0Y2gsXG4gICAgICAgIFtvYXV0aC5hbGxvd0luc2VjdXJlUmVxdWVzdHNdOiAhdGxzT25seSxcbiAgICAgICAgYWRkaXRpb25hbFBhcmFtZXRlcnM6IHBhcmFtZXRlcnMsXG4gICAgICAgIERQb1A6IG9wdGlvbnM/LkRQb1AsXG4gICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKGhlYWRlcnMpLFxuICAgICAgICBzaWduYWw6IHBvbGxpbmdTaWduYWwuYWJvcnRlZCA/IHBvbGxpbmdTaWduYWwgOiBzaWduYWwodGltZW91dCksXG4gICAgfSlcbiAgICAgICAgLmNhdGNoKGVycm9ySGFuZGxlcik7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNTAzICYmIHJlc3BvbnNlLmhlYWRlcnMuaGFzKCdyZXRyeS1hZnRlcicpKSB7XG4gICAgICAgIGF3YWl0IGhhbmRsZVJldHJ5QWZ0ZXIocmVzcG9uc2UsIGludGVydmFsLCBwb2xsaW5nU2lnbmFsLCB0cnVlKTtcbiAgICAgICAgYXdhaXQgcmVzcG9uc2UuYm9keT8uY2FuY2VsKCk7XG4gICAgICAgIHJldHVybiByZXRyeVBvbGwoaW50ZXJ2YWwpO1xuICAgIH1cbiAgICBjb25zdCBwID0gb2F1dGgucHJvY2Vzc0JhY2tjaGFubmVsQXV0aGVudGljYXRpb25HcmFudFJlc3BvbnNlKGFzLCBjLCByZXNwb25zZSwge1xuICAgICAgICBbb2F1dGguandlRGVjcnlwdF06IGRlY3J5cHQsXG4gICAgfSk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBhd2FpdCBwO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChyZXRyeWFibGUoZXJyLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJldHJ5UG9sbChpbnRlcnZhbCwgcmV0cnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBvYXV0aC5SZXNwb25zZUJvZHlFcnJvcikge1xuICAgICAgICAgICAgc3dpdGNoIChlcnIuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzbG93X2Rvd24nOlxuICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbCArPSA1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2F1dGhvcml6YXRpb25fcGVuZGluZyc6XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGhhbmRsZVJldHJ5QWZ0ZXIoZXJyLnJlc3BvbnNlLCBpbnRlcnZhbCwgcG9sbGluZ1NpZ25hbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXRyeVBvbGwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9ySGFuZGxlcihlcnIpO1xuICAgIH1cbiAgICByZXN1bHQuaWRfdG9rZW4gJiYgKGF3YWl0IG5vblJlcHVkaWF0aW9uPy4ocmVzcG9uc2UpKTtcbiAgICBhZGRIZWxwZXJzKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhbGxvd0luc2VjdXJlUmVxdWVzdHMoY29uZmlnKSB7XG4gICAgaW50KGNvbmZpZykudGxzT25seSA9IGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldEp3a3NDYWNoZShjb25maWcsIGp3a3NDYWNoZSkge1xuICAgIGludChjb25maWcpLmp3a3NDYWNoZSA9IHN0cnVjdHVyZWRDbG9uZShqd2tzQ2FjaGUpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEp3a3NDYWNoZShjb25maWcpIHtcbiAgICBjb25zdCBjYWNoZSA9IGludChjb25maWcpLmp3a3NDYWNoZTtcbiAgICBpZiAoY2FjaGUudWF0KSB7XG4gICAgICAgIHJldHVybiBjYWNoZTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVOb25SZXB1ZGlhdGlvbkNoZWNrcyhjb25maWcpIHtcbiAgICBjaGVja0NvbmZpZyhjb25maWcpO1xuICAgIGludChjb25maWcpLm5vblJlcHVkaWF0aW9uID0gKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgYXMsIGZldGNoLCB0bHNPbmx5LCB0aW1lb3V0LCBqd2tzQ2FjaGUgfSA9IGludChjb25maWcpO1xuICAgICAgICByZXR1cm4gb2F1dGhcbiAgICAgICAgICAgIC52YWxpZGF0ZUFwcGxpY2F0aW9uTGV2ZWxTaWduYXR1cmUoYXMsIHJlc3BvbnNlLCB7XG4gICAgICAgICAgICBbb2F1dGguY3VzdG9tRmV0Y2hdOiBmZXRjaCxcbiAgICAgICAgICAgIFtvYXV0aC5hbGxvd0luc2VjdXJlUmVxdWVzdHNdOiAhdGxzT25seSxcbiAgICAgICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKGhlYWRlcnMpLFxuICAgICAgICAgICAgc2lnbmFsOiBzaWduYWwodGltZW91dCksXG4gICAgICAgICAgICBbb2F1dGguandrc0NhY2hlXTogandrc0NhY2hlLFxuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGVycm9ySGFuZGxlcik7XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1c2VKd3RSZXNwb25zZU1vZGUoY29uZmlnKSB7XG4gICAgY2hlY2tDb25maWcoY29uZmlnKTtcbiAgICBjb25zdCB7IGh5YnJpZCwgaW1wbGljaXQgfSA9IGludChjb25maWcpO1xuICAgIGlmIChoeWJyaWQgfHwgaW1wbGljaXQpIHtcbiAgICAgICAgdGhyb3cgZSgnSkFSTSBjYW5ub3QgYmUgY29tYmluZWQgd2l0aCBhIGh5YnJpZCBvciBpbXBsaWNpdCByZXNwb25zZSB0eXBlcycsIHVuZGVmaW5lZCwgb2F1dGguVU5TVVBQT1JURURfT1BFUkFUSU9OKTtcbiAgICB9XG4gICAgaW50KGNvbmZpZykuamFybSA9IChhdXRob3JpemF0aW9uUmVzcG9uc2UsIGV4cGVjdGVkU3RhdGUpID0+IHZhbGlkYXRlSkFSTVJlc3BvbnNlKGNvbmZpZywgYXV0aG9yaXphdGlvblJlc3BvbnNlLCBleHBlY3RlZFN0YXRlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVEZXRhY2hlZFNpZ25hdHVyZVJlc3BvbnNlQ2hlY2tzKGNvbmZpZykge1xuICAgIGlmICghaW50KGNvbmZpZykuaHlicmlkKSB7XG4gICAgICAgIHRocm93IGUoJ1wiY29kZSBpZF90b2tlblwiIHJlc3BvbnNlIHR5cGUgbXVzdCBiZSBjb25maWd1cmVkIHRvIGJlIHVzZWQgZmlyc3QnLCB1bmRlZmluZWQsIG9hdXRoLlVOU1VQUE9SVEVEX09QRVJBVElPTik7XG4gICAgfVxuICAgIGludChjb25maWcpLmh5YnJpZCA9IChhdXRob3JpemF0aW9uUmVzcG9uc2UsIGV4cGVjdGVkTm9uY2UsIGV4cGVjdGVkU3RhdGUsIG1heEFnZSkgPT4gdmFsaWRhdGVDb2RlSWRUb2tlblJlc3BvbnNlKGNvbmZpZywgYXV0aG9yaXphdGlvblJlc3BvbnNlLCBleHBlY3RlZE5vbmNlLCBleHBlY3RlZFN0YXRlLCBtYXhBZ2UsIHRydWUpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGltcGxpY2l0QXV0aGVudGljYXRpb24oY29uZmlnLCBjdXJyZW50VXJsLCBleHBlY3RlZE5vbmNlLCBjaGVja3MpIHtcbiAgICBjaGVja0NvbmZpZyhjb25maWcpO1xuICAgIGlmICghKGN1cnJlbnRVcmwgaW5zdGFuY2VvZiBVUkwpICYmXG4gICAgICAgICF3ZWJJbnN0YW5jZU9mKGN1cnJlbnRVcmwsICdSZXF1ZXN0JykpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wiY3VycmVudFVybFwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVVJMLCBvciBSZXF1ZXN0JywgRVJSX0lOVkFMSURfQVJHX1RZUEUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkTm9uY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IENvZGVkVHlwZUVycm9yKCdcImV4cGVjdGVkTm9uY2VcIiBtdXN0IGJlIGEgc3RyaW5nJywgRVJSX0lOVkFMSURfQVJHX1RZUEUpO1xuICAgIH1cbiAgICBjb25zdCB7IGFzLCBjLCBmZXRjaCwgdGxzT25seSwgdGltZW91dCwgZGVjcnlwdCwgaW1wbGljaXQsIGp3a3NDYWNoZSB9ID0gaW50KGNvbmZpZyk7XG4gICAgaWYgKCFpbXBsaWNpdCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbXBsaWNpdEF1dGhlbnRpY2F0aW9uKCkgY2Fubm90IGJlIHVzZWQgYnkgY2xpZW50cyB1c2luZyBmbG93cyBvdGhlciB0aGFuIHJlc3BvbnNlX3R5cGU9aWRfdG9rZW4nKTtcbiAgICB9XG4gICAgbGV0IHBhcmFtcztcbiAgICBpZiAoIShjdXJyZW50VXJsIGluc3RhbmNlb2YgVVJMKSkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gY3VycmVudFVybDtcbiAgICAgICAgc3dpdGNoIChyZXF1ZXN0Lm1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSAnR0VUJzpcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG5ldyBVUkwocmVxdWVzdC51cmwpLmhhc2guc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUE9TVCc6XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhhd2FpdCBvYXV0aC5mb3JtUG9zdFJlc3BvbnNlKHJlcXVlc3QpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ3VuZXhwZWN0ZWQgUmVxdWVzdCBIVFRQIG1ldGhvZCcsIEVSUl9JTlZBTElEX0FSR19WQUxVRSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoY3VycmVudFVybC5oYXNoLnNsaWNlKDEpKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZGVjb3kgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtcyk7XG4gICAgICAgICAgICBkZWNveS5kZWxldGUoJ2lkX3Rva2VuJyk7XG4gICAgICAgICAgICBvYXV0aC52YWxpZGF0ZUF1dGhSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgLi4uYXMsXG4gICAgICAgICAgICAgICAgYXV0aG9yaXphdGlvbl9yZXNwb25zZV9pc3NfcGFyYW1ldGVyX3N1cHBvcnRlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSwgYywgZGVjb3ksIGNoZWNrcz8uZXhwZWN0ZWRTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgZGVjb3kgPSBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIGFjY2Vzc190b2tlbjogJ2RlY295JyxcbiAgICAgICAgICAgICAgICB0b2tlbl90eXBlOiAnYmVhcmVyJyxcbiAgICAgICAgICAgICAgICBpZF90b2tlbjogcGFyYW1zLmdldCgnaWRfdG9rZW4nKSxcbiAgICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoeyAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZWYgPSBhd2FpdCBvYXV0aC5wcm9jZXNzQXV0aG9yaXphdGlvbkNvZGVSZXNwb25zZShhcywgYywgZGVjb3ksIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZE5vbmNlLFxuICAgICAgICAgICAgICAgIG1heEFnZTogY2hlY2tzPy5tYXhBZ2UsXG4gICAgICAgICAgICAgICAgW29hdXRoLmp3ZURlY3J5cHRdOiBkZWNyeXB0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCBvYXV0aC52YWxpZGF0ZUFwcGxpY2F0aW9uTGV2ZWxTaWduYXR1cmUoYXMsIGRlY295LCB7XG4gICAgICAgICAgICAgICAgW29hdXRoLmN1c3RvbUZldGNoXTogZmV0Y2gsXG4gICAgICAgICAgICAgICAgW29hdXRoLmFsbG93SW5zZWN1cmVSZXF1ZXN0c106ICF0bHNPbmx5LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKGhlYWRlcnMpLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogc2lnbmFsKHRpbWVvdXQpLFxuICAgICAgICAgICAgICAgIFtvYXV0aC5qd2tzQ2FjaGVdOiBqd2tzQ2FjaGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvYXV0aC5nZXRWYWxpZGF0ZWRJZFRva2VuQ2xhaW1zKHJlZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBlcnJvckhhbmRsZXIoZXJyKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gdXNlQ29kZUlkVG9rZW5SZXNwb25zZVR5cGUoY29uZmlnKSB7XG4gICAgY2hlY2tDb25maWcoY29uZmlnKTtcbiAgICBjb25zdCB7IGphcm0sIGltcGxpY2l0IH0gPSBpbnQoY29uZmlnKTtcbiAgICBpZiAoamFybSB8fCBpbXBsaWNpdCkge1xuICAgICAgICB0aHJvdyBlKCdcImNvZGUgaWRfdG9rZW5cIiByZXNwb25zZSB0eXBlIGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIEpBUk0gb3IgaW1wbGljaXQgcmVzcG9uc2UgdHlwZScsIHVuZGVmaW5lZCwgb2F1dGguVU5TVVBQT1JURURfT1BFUkFUSU9OKTtcbiAgICB9XG4gICAgaW50KGNvbmZpZykuaHlicmlkID0gKGF1dGhvcml6YXRpb25SZXNwb25zZSwgZXhwZWN0ZWROb25jZSwgZXhwZWN0ZWRTdGF0ZSwgbWF4QWdlKSA9PiB2YWxpZGF0ZUNvZGVJZFRva2VuUmVzcG9uc2UoY29uZmlnLCBhdXRob3JpemF0aW9uUmVzcG9uc2UsIGV4cGVjdGVkTm9uY2UsIGV4cGVjdGVkU3RhdGUsIG1heEFnZSwgZmFsc2UpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZUlkVG9rZW5SZXNwb25zZVR5cGUoY29uZmlnKSB7XG4gICAgY2hlY2tDb25maWcoY29uZmlnKTtcbiAgICBjb25zdCB7IGphcm0sIGh5YnJpZCB9ID0gaW50KGNvbmZpZyk7XG4gICAgaWYgKGphcm0gfHwgaHlicmlkKSB7XG4gICAgICAgIHRocm93IGUoJ1wiaWRfdG9rZW5cIiByZXNwb25zZSB0eXBlIGNhbm5vdCBiZSBjb21iaW5lZCB3aXRoIEpBUk0gb3IgaHlicmlkIHJlc3BvbnNlIHR5cGUnLCB1bmRlZmluZWQsIG9hdXRoLlVOU1VQUE9SVEVEX09QRVJBVElPTik7XG4gICAgfVxuICAgIGludChjb25maWcpLmltcGxpY2l0ID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHN0cmlwUGFyYW1zKHVybCkge1xuICAgIHVybCA9IG5ldyBVUkwodXJsKTtcbiAgICB1cmwuc2VhcmNoID0gJyc7XG4gICAgdXJsLmhhc2ggPSAnJztcbiAgICByZXR1cm4gdXJsLmhyZWY7XG59XG5mdW5jdGlvbiB3ZWJJbnN0YW5jZU9mKGlucHV0LCB0b1N0cmluZ1RhZykge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5wdXQpW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09IHRvU3RyaW5nVGFnO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXV0aG9yaXphdGlvbkNvZGVHcmFudChjb25maWcsIGN1cnJlbnRVcmwsIGNoZWNrcywgdG9rZW5FbmRwb2ludFBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICBjaGVja0NvbmZpZyhjb25maWcpO1xuICAgIGlmIChvcHRpb25zPy5mbGFnICE9PSByZXRyeSAmJlxuICAgICAgICAhKGN1cnJlbnRVcmwgaW5zdGFuY2VvZiBVUkwpICYmXG4gICAgICAgICF3ZWJJbnN0YW5jZU9mKGN1cnJlbnRVcmwsICdSZXF1ZXN0JykpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wiY3VycmVudFVybFwiIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVVJMLCBvciBSZXF1ZXN0JywgRVJSX0lOVkFMSURfQVJHX1RZUEUpO1xuICAgIH1cbiAgICBsZXQgYXV0aFJlc3BvbnNlO1xuICAgIGxldCByZWRpcmVjdFVyaTtcbiAgICBjb25zdCB7IGFzLCBjLCBhdXRoLCBmZXRjaCwgdGxzT25seSwgamFybSwgaHlicmlkLCBub25SZXB1ZGlhdGlvbiwgdGltZW91dCwgZGVjcnlwdCwgaW1wbGljaXQgfSA9IGludChjb25maWcpO1xuICAgIGlmIChvcHRpb25zPy5mbGFnID09PSByZXRyeSkge1xuICAgICAgICBhdXRoUmVzcG9uc2UgPSBvcHRpb25zLmF1dGhSZXNwb25zZTtcbiAgICAgICAgcmVkaXJlY3RVcmkgPSBvcHRpb25zLnJlZGlyZWN0VXJpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCEoY3VycmVudFVybCBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBjdXJyZW50VXJsO1xuICAgICAgICAgICAgY3VycmVudFVybCA9IG5ldyBVUkwoY3VycmVudFVybC51cmwpO1xuICAgICAgICAgICAgc3dpdGNoIChyZXF1ZXN0Lm1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ0dFVCc6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1BPU1QnOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKGF3YWl0IG9hdXRoLmZvcm1Qb3N0UmVzcG9uc2UocmVxdWVzdCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaHlicmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VXJsLmhhc2ggPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIHBhcmFtcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoaywgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ3VuZXhwZWN0ZWQgUmVxdWVzdCBIVFRQIG1ldGhvZCcsIEVSUl9JTlZBTElEX0FSR19WQUxVRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVkaXJlY3RVcmkgPSBzdHJpcFBhcmFtcyhjdXJyZW50VXJsKTtcbiAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICBjYXNlICEhamFybTpcbiAgICAgICAgICAgICAgICBhdXRoUmVzcG9uc2UgPSBhd2FpdCBqYXJtKGN1cnJlbnRVcmwsIGNoZWNrcz8uZXhwZWN0ZWRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICEhaHlicmlkOlxuICAgICAgICAgICAgICAgIGF1dGhSZXNwb25zZSA9IGF3YWl0IGh5YnJpZChjdXJyZW50VXJsLCBjaGVja3M/LmV4cGVjdGVkTm9uY2UsIGNoZWNrcz8uZXhwZWN0ZWRTdGF0ZSwgY2hlY2tzPy5tYXhBZ2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAhIWltcGxpY2l0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F1dGhvcml6YXRpb25Db2RlR3JhbnQoKSBjYW5ub3QgYmUgdXNlZCBieSByZXNwb25zZV90eXBlPWlkX3Rva2VuIGNsaWVudHMnKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXV0aFJlc3BvbnNlID0gb2F1dGgudmFsaWRhdGVBdXRoUmVzcG9uc2UoYXMsIGMsIGN1cnJlbnRVcmwuc2VhcmNoUGFyYW1zLCBjaGVja3M/LmV4cGVjdGVkU3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG9hdXRoXG4gICAgICAgIC5hdXRob3JpemF0aW9uQ29kZUdyYW50UmVxdWVzdChhcywgYywgYXV0aCwgYXV0aFJlc3BvbnNlLCByZWRpcmVjdFVyaSwgY2hlY2tzPy5wa2NlQ29kZVZlcmlmaWVyIHx8IG9hdXRoLm5vcGtjZSwge1xuICAgICAgICBhZGRpdGlvbmFsUGFyYW1ldGVyczogdG9rZW5FbmRwb2ludFBhcmFtZXRlcnMsXG4gICAgICAgIFtvYXV0aC5jdXN0b21GZXRjaF06IGZldGNoLFxuICAgICAgICBbb2F1dGguYWxsb3dJbnNlY3VyZVJlcXVlc3RzXTogIXRsc09ubHksXG4gICAgICAgIERQb1A6IG9wdGlvbnM/LkRQb1AsXG4gICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKGhlYWRlcnMpLFxuICAgICAgICBzaWduYWw6IHNpZ25hbCh0aW1lb3V0KSxcbiAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyb3JIYW5kbGVyKTtcbiAgICBpZiAodHlwZW9mIGNoZWNrcz8uZXhwZWN0ZWROb25jZSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgdHlwZW9mIGNoZWNrcz8ubWF4QWdlID09PSAnbnVtYmVyJykge1xuICAgICAgICBjaGVja3MuaWRUb2tlbkV4cGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgcCA9IG9hdXRoLnByb2Nlc3NBdXRob3JpemF0aW9uQ29kZVJlc3BvbnNlKGFzLCBjLCByZXNwb25zZSwge1xuICAgICAgICBleHBlY3RlZE5vbmNlOiBjaGVja3M/LmV4cGVjdGVkTm9uY2UsXG4gICAgICAgIG1heEFnZTogY2hlY2tzPy5tYXhBZ2UsXG4gICAgICAgIHJlcXVpcmVJZFRva2VuOiBjaGVja3M/LmlkVG9rZW5FeHBlY3RlZCxcbiAgICAgICAgW29hdXRoLmp3ZURlY3J5cHRdOiBkZWNyeXB0LFxuICAgIH0pO1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgcDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAocmV0cnlhYmxlKGVyciwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybiBhdXRob3JpemF0aW9uQ29kZUdyYW50KGNvbmZpZywgdW5kZWZpbmVkLCBjaGVja3MsIHRva2VuRW5kcG9pbnRQYXJhbWV0ZXJzLCB7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBmbGFnOiByZXRyeSxcbiAgICAgICAgICAgICAgICBhdXRoUmVzcG9uc2U6IGF1dGhSZXNwb25zZSxcbiAgICAgICAgICAgICAgICByZWRpcmVjdFVyaTogcmVkaXJlY3RVcmksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvckhhbmRsZXIoZXJyKTtcbiAgICB9XG4gICAgcmVzdWx0LmlkX3Rva2VuICYmIChhd2FpdCBub25SZXB1ZGlhdGlvbj8uKHJlc3BvbnNlKSk7XG4gICAgYWRkSGVscGVycyhyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5hc3luYyBmdW5jdGlvbiB2YWxpZGF0ZUpBUk1SZXNwb25zZShjb25maWcsIGF1dGhvcml6YXRpb25SZXNwb25zZSwgZXhwZWN0ZWRTdGF0ZSkge1xuICAgIGNvbnN0IHsgYXMsIGMsIGZldGNoLCB0bHNPbmx5LCB0aW1lb3V0LCBkZWNyeXB0LCBqd2tzQ2FjaGUgfSA9IGludChjb25maWcpO1xuICAgIHJldHVybiBvYXV0aFxuICAgICAgICAudmFsaWRhdGVKd3RBdXRoUmVzcG9uc2UoYXMsIGMsIGF1dGhvcml6YXRpb25SZXNwb25zZSwgZXhwZWN0ZWRTdGF0ZSwge1xuICAgICAgICBbb2F1dGguY3VzdG9tRmV0Y2hdOiBmZXRjaCxcbiAgICAgICAgW29hdXRoLmFsbG93SW5zZWN1cmVSZXF1ZXN0c106ICF0bHNPbmx5LFxuICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhoZWFkZXJzKSxcbiAgICAgICAgc2lnbmFsOiBzaWduYWwodGltZW91dCksXG4gICAgICAgIFtvYXV0aC5qd2VEZWNyeXB0XTogZGVjcnlwdCxcbiAgICAgICAgW29hdXRoLmp3a3NDYWNoZV06IGp3a3NDYWNoZSxcbiAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyb3JIYW5kbGVyKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlQ29kZUlkVG9rZW5SZXNwb25zZShjb25maWcsIGF1dGhvcml6YXRpb25SZXNwb25zZSwgZXhwZWN0ZWROb25jZSwgZXhwZWN0ZWRTdGF0ZSwgbWF4QWdlLCBmYXBpKSB7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZE5vbmNlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJleHBlY3RlZE5vbmNlXCIgbXVzdCBiZSBhIHN0cmluZycsIEVSUl9JTlZBTElEX0FSR19UWVBFKTtcbiAgICB9XG4gICAgaWYgKGV4cGVjdGVkU3RhdGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZXhwZWN0ZWRTdGF0ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wiZXhwZWN0ZWRTdGF0ZVwiIG11c3QgYmUgYSBzdHJpbmcnLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSk7XG4gICAgfVxuICAgIGNvbnN0IHsgYXMsIGMsIGZldGNoLCB0bHNPbmx5LCB0aW1lb3V0LCBkZWNyeXB0LCBqd2tzQ2FjaGUgfSA9IGludChjb25maWcpO1xuICAgIHJldHVybiAoZmFwaVxuICAgICAgICA/IG9hdXRoLnZhbGlkYXRlRGV0YWNoZWRTaWduYXR1cmVSZXNwb25zZVxuICAgICAgICA6IG9hdXRoLnZhbGlkYXRlQ29kZUlkVG9rZW5SZXNwb25zZSkoYXMsIGMsIGF1dGhvcml6YXRpb25SZXNwb25zZSwgZXhwZWN0ZWROb25jZSwgZXhwZWN0ZWRTdGF0ZSwgbWF4QWdlLCB7XG4gICAgICAgIFtvYXV0aC5jdXN0b21GZXRjaF06IGZldGNoLFxuICAgICAgICBbb2F1dGguYWxsb3dJbnNlY3VyZVJlcXVlc3RzXTogIXRsc09ubHksXG4gICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKGhlYWRlcnMpLFxuICAgICAgICBzaWduYWw6IHNpZ25hbCh0aW1lb3V0KSxcbiAgICAgICAgW29hdXRoLmp3ZURlY3J5cHRdOiBkZWNyeXB0LFxuICAgICAgICBbb2F1dGguandrc0NhY2hlXTogandrc0NhY2hlLFxuICAgIH0pLmNhdGNoKGVycm9ySGFuZGxlcik7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVmcmVzaFRva2VuR3JhbnQoY29uZmlnLCByZWZyZXNoVG9rZW4sIHBhcmFtZXRlcnMsIG9wdGlvbnMpIHtcbiAgICBjaGVja0NvbmZpZyhjb25maWcpO1xuICAgIHBhcmFtZXRlcnMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtZXRlcnMpO1xuICAgIGNvbnN0IHsgYXMsIGMsIGF1dGgsIGZldGNoLCB0bHNPbmx5LCBub25SZXB1ZGlhdGlvbiwgdGltZW91dCwgZGVjcnlwdCB9ID0gaW50KGNvbmZpZyk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBvYXV0aFxuICAgICAgICAucmVmcmVzaFRva2VuR3JhbnRSZXF1ZXN0KGFzLCBjLCBhdXRoLCByZWZyZXNoVG9rZW4sIHtcbiAgICAgICAgW29hdXRoLmN1c3RvbUZldGNoXTogZmV0Y2gsXG4gICAgICAgIFtvYXV0aC5hbGxvd0luc2VjdXJlUmVxdWVzdHNdOiAhdGxzT25seSxcbiAgICAgICAgYWRkaXRpb25hbFBhcmFtZXRlcnM6IHBhcmFtZXRlcnMsXG4gICAgICAgIERQb1A6IG9wdGlvbnM/LkRQb1AsXG4gICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKGhlYWRlcnMpLFxuICAgICAgICBzaWduYWw6IHNpZ25hbCh0aW1lb3V0KSxcbiAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyb3JIYW5kbGVyKTtcbiAgICBjb25zdCBwID0gb2F1dGgucHJvY2Vzc1JlZnJlc2hUb2tlblJlc3BvbnNlKGFzLCBjLCByZXNwb25zZSwge1xuICAgICAgICBbb2F1dGguandlRGVjcnlwdF06IGRlY3J5cHQsXG4gICAgfSk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBhd2FpdCBwO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChyZXRyeWFibGUoZXJyLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZnJlc2hUb2tlbkdyYW50KGNvbmZpZywgcmVmcmVzaFRva2VuLCBwYXJhbWV0ZXJzLCB7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBmbGFnOiByZXRyeSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVycm9ySGFuZGxlcihlcnIpO1xuICAgIH1cbiAgICByZXN1bHQuaWRfdG9rZW4gJiYgKGF3YWl0IG5vblJlcHVkaWF0aW9uPy4ocmVzcG9uc2UpKTtcbiAgICBhZGRIZWxwZXJzKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjbGllbnRDcmVkZW50aWFsc0dyYW50KGNvbmZpZywgcGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgIGNoZWNrQ29uZmlnKGNvbmZpZyk7XG4gICAgcGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1ldGVycyk7XG4gICAgY29uc3QgeyBhcywgYywgYXV0aCwgZmV0Y2gsIHRsc09ubHksIHRpbWVvdXQgfSA9IGludChjb25maWcpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb2F1dGhcbiAgICAgICAgLmNsaWVudENyZWRlbnRpYWxzR3JhbnRSZXF1ZXN0KGFzLCBjLCBhdXRoLCBwYXJhbWV0ZXJzLCB7XG4gICAgICAgIFtvYXV0aC5jdXN0b21GZXRjaF06IGZldGNoLFxuICAgICAgICBbb2F1dGguYWxsb3dJbnNlY3VyZVJlcXVlc3RzXTogIXRsc09ubHksXG4gICAgICAgIERQb1A6IG9wdGlvbnM/LkRQb1AsXG4gICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKGhlYWRlcnMpLFxuICAgICAgICBzaWduYWw6IHNpZ25hbCh0aW1lb3V0KSxcbiAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyb3JIYW5kbGVyKTtcbiAgICBjb25zdCBwID0gb2F1dGgucHJvY2Vzc0NsaWVudENyZWRlbnRpYWxzUmVzcG9uc2UoYXMsIGMsIHJlc3BvbnNlKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IGF3YWl0IHA7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKHJldHJ5YWJsZShlcnIsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xpZW50Q3JlZGVudGlhbHNHcmFudChjb25maWcsIHBhcmFtZXRlcnMsIHtcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGZsYWc6IHJldHJ5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3JIYW5kbGVyKGVycik7XG4gICAgfVxuICAgIGFkZEhlbHBlcnMocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkQXV0aG9yaXphdGlvblVybChjb25maWcsIHBhcmFtZXRlcnMpIHtcbiAgICBjaGVja0NvbmZpZyhjb25maWcpO1xuICAgIGNvbnN0IHsgYXMsIGMsIHRsc09ubHksIGh5YnJpZCwgamFybSwgaW1wbGljaXQgfSA9IGludChjb25maWcpO1xuICAgIGNvbnN0IGF1dGhvcml6YXRpb25FbmRwb2ludCA9IG9hdXRoLnJlc29sdmVFbmRwb2ludChhcywgJ2F1dGhvcml6YXRpb25fZW5kcG9pbnQnLCBmYWxzZSwgdGxzT25seSk7XG4gICAgcGFyYW1ldGVycyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1ldGVycyk7XG4gICAgaWYgKCFwYXJhbWV0ZXJzLmhhcygnY2xpZW50X2lkJykpIHtcbiAgICAgICAgcGFyYW1ldGVycy5zZXQoJ2NsaWVudF9pZCcsIGMuY2xpZW50X2lkKTtcbiAgICB9XG4gICAgaWYgKCFwYXJhbWV0ZXJzLmhhcygncmVxdWVzdF91cmknKSAmJiAhcGFyYW1ldGVycy5oYXMoJ3JlcXVlc3QnKSkge1xuICAgICAgICBpZiAoIXBhcmFtZXRlcnMuaGFzKCdyZXNwb25zZV90eXBlJykpIHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuc2V0KCdyZXNwb25zZV90eXBlJywgaHlicmlkID8gJ2NvZGUgaWRfdG9rZW4nIDogaW1wbGljaXQgPyAnaWRfdG9rZW4nIDogJ2NvZGUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1wbGljaXQgJiYgIXBhcmFtZXRlcnMuaGFzKCdub25jZScpKSB7XG4gICAgICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcigncmVzcG9uc2VfdHlwZT1pZF90b2tlbiBjbGllbnRzIG11c3QgcHJvdmlkZSBhIG5vbmNlIHBhcmFtZXRlciBpbiB0aGVpciBhdXRob3JpemF0aW9uIHJlcXVlc3QgcGFyYW1ldGVycycsIEVSUl9JTlZBTElEX0FSR19WQUxVRSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGphcm0pIHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuc2V0KCdyZXNwb25zZV9tb2RlJywgJ2p3dCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIHBhcmFtZXRlcnMuZW50cmllcygpKSB7XG4gICAgICAgIGF1dGhvcml6YXRpb25FbmRwb2ludC5zZWFyY2hQYXJhbXMuYXBwZW5kKGssIHYpO1xuICAgIH1cbiAgICByZXR1cm4gYXV0aG9yaXphdGlvbkVuZHBvaW50O1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJ1aWxkQXV0aG9yaXphdGlvblVybFdpdGhKQVIoY29uZmlnLCBwYXJhbWV0ZXJzLCBzaWduaW5nS2V5LCBvcHRpb25zKSB7XG4gICAgY2hlY2tDb25maWcoY29uZmlnKTtcbiAgICBjb25zdCBhdXRob3JpemF0aW9uRW5kcG9pbnQgPSBidWlsZEF1dGhvcml6YXRpb25VcmwoY29uZmlnLCBwYXJhbWV0ZXJzKTtcbiAgICBwYXJhbWV0ZXJzID0gYXV0aG9yaXphdGlvbkVuZHBvaW50LnNlYXJjaFBhcmFtcztcbiAgICBpZiAoIXNpZ25pbmdLZXkpIHtcbiAgICAgICAgdGhyb3cgQ29kZWRUeXBlRXJyb3IoJ1wic2lnbmluZ0tleVwiIG11c3QgYmUgcHJvdmlkZWQnLCBFUlJfSU5WQUxJRF9BUkdfVkFMVUUpO1xuICAgIH1cbiAgICBjb25zdCB7IGFzLCBjIH0gPSBpbnQoY29uZmlnKTtcbiAgICBjb25zdCByZXF1ZXN0ID0gYXdhaXQgb2F1dGhcbiAgICAgICAgLmlzc3VlUmVxdWVzdE9iamVjdChhcywgYywgcGFyYW1ldGVycywgc2lnbmluZ0tleSwgb3B0aW9ucylcbiAgICAgICAgLmNhdGNoKGVycm9ySGFuZGxlcik7XG4gICAgcmV0dXJuIGJ1aWxkQXV0aG9yaXphdGlvblVybChjb25maWcsIHsgcmVxdWVzdCB9KTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBidWlsZEF1dGhvcml6YXRpb25VcmxXaXRoUEFSKGNvbmZpZywgcGFyYW1ldGVycywgb3B0aW9ucykge1xuICAgIGNoZWNrQ29uZmlnKGNvbmZpZyk7XG4gICAgY29uc3QgYXV0aG9yaXphdGlvbkVuZHBvaW50ID0gYnVpbGRBdXRob3JpemF0aW9uVXJsKGNvbmZpZywgcGFyYW1ldGVycyk7XG4gICAgY29uc3QgeyBhcywgYywgYXV0aCwgZmV0Y2gsIHRsc09ubHksIHRpbWVvdXQgfSA9IGludChjb25maWcpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb2F1dGhcbiAgICAgICAgLnB1c2hlZEF1dGhvcml6YXRpb25SZXF1ZXN0KGFzLCBjLCBhdXRoLCBhdXRob3JpemF0aW9uRW5kcG9pbnQuc2VhcmNoUGFyYW1zLCB7XG4gICAgICAgIFtvYXV0aC5jdXN0b21GZXRjaF06IGZldGNoLFxuICAgICAgICBbb2F1dGguYWxsb3dJbnNlY3VyZVJlcXVlc3RzXTogIXRsc09ubHksXG4gICAgICAgIERQb1A6IG9wdGlvbnM/LkRQb1AsXG4gICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKGhlYWRlcnMpLFxuICAgICAgICBzaWduYWw6IHNpZ25hbCh0aW1lb3V0KSxcbiAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyb3JIYW5kbGVyKTtcbiAgICBjb25zdCBwID0gb2F1dGgucHJvY2Vzc1B1c2hlZEF1dGhvcml6YXRpb25SZXNwb25zZShhcywgYywgcmVzcG9uc2UpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgcDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAocmV0cnlhYmxlKGVyciwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybiBidWlsZEF1dGhvcml6YXRpb25VcmxXaXRoUEFSKGNvbmZpZywgcGFyYW1ldGVycywge1xuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgZmxhZzogcmV0cnksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvckhhbmRsZXIoZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWxkQXV0aG9yaXphdGlvblVybChjb25maWcsIHsgcmVxdWVzdF91cmk6IHJlc3VsdC5yZXF1ZXN0X3VyaSB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEVuZFNlc3Npb25VcmwoY29uZmlnLCBwYXJhbWV0ZXJzKSB7XG4gICAgY2hlY2tDb25maWcoY29uZmlnKTtcbiAgICBjb25zdCB7IGFzLCBjLCB0bHNPbmx5IH0gPSBpbnQoY29uZmlnKTtcbiAgICBjb25zdCBlbmRTZXNzaW9uRW5kcG9pbnQgPSBvYXV0aC5yZXNvbHZlRW5kcG9pbnQoYXMsICdlbmRfc2Vzc2lvbl9lbmRwb2ludCcsIGZhbHNlLCB0bHNPbmx5KTtcbiAgICBwYXJhbWV0ZXJzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbWV0ZXJzKTtcbiAgICBpZiAoIXBhcmFtZXRlcnMuaGFzKCdjbGllbnRfaWQnKSkge1xuICAgICAgICBwYXJhbWV0ZXJzLnNldCgnY2xpZW50X2lkJywgYy5jbGllbnRfaWQpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBwYXJhbWV0ZXJzLmVudHJpZXMoKSkge1xuICAgICAgICBlbmRTZXNzaW9uRW5kcG9pbnQuc2VhcmNoUGFyYW1zLmFwcGVuZChrLCB2KTtcbiAgICB9XG4gICAgcmV0dXJuIGVuZFNlc3Npb25FbmRwb2ludDtcbn1cbmZ1bmN0aW9uIGNoZWNrQ29uZmlnKGlucHV0KSB7XG4gICAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiBDb25maWd1cmF0aW9uKSkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignXCJjb25maWdcIiBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIENvbmZpZ3VyYXRpb24nLCBFUlJfSU5WQUxJRF9BUkdfVFlQRSk7XG4gICAgfVxuICAgIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5wdXQpICE9PSBDb25maWd1cmF0aW9uLnByb3RvdHlwZSkge1xuICAgICAgICB0aHJvdyBDb2RlZFR5cGVFcnJvcignc3ViY2xhc3NpbmcgQ29uZmlndXJhdGlvbiBpcyBub3QgYWxsb3dlZCcsIEVSUl9JTlZBTElEX0FSR19WQUxVRSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2lnbmFsKHRpbWVvdXQpIHtcbiAgICByZXR1cm4gdGltZW91dCA/IEFib3J0U2lnbmFsLnRpbWVvdXQodGltZW91dCAqIDEwMDApIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoVXNlckluZm8oY29uZmlnLCBhY2Nlc3NUb2tlbiwgZXhwZWN0ZWRTdWJqZWN0LCBvcHRpb25zKSB7XG4gICAgY2hlY2tDb25maWcoY29uZmlnKTtcbiAgICBjb25zdCB7IGFzLCBjLCBmZXRjaCwgdGxzT25seSwgbm9uUmVwdWRpYXRpb24sIHRpbWVvdXQsIGRlY3J5cHQgfSA9IGludChjb25maWcpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb2F1dGhcbiAgICAgICAgLnVzZXJJbmZvUmVxdWVzdChhcywgYywgYWNjZXNzVG9rZW4sIHtcbiAgICAgICAgW29hdXRoLmN1c3RvbUZldGNoXTogZmV0Y2gsXG4gICAgICAgIFtvYXV0aC5hbGxvd0luc2VjdXJlUmVxdWVzdHNdOiAhdGxzT25seSxcbiAgICAgICAgRFBvUDogb3B0aW9ucz8uRFBvUCxcbiAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoaGVhZGVycyksXG4gICAgICAgIHNpZ25hbDogc2lnbmFsKHRpbWVvdXQpLFxuICAgIH0pXG4gICAgICAgIC5jYXRjaChlcnJvckhhbmRsZXIpO1xuICAgIGxldCBleGVjID0gb2F1dGgucHJvY2Vzc1VzZXJJbmZvUmVzcG9uc2UoYXMsIGMsIGV4cGVjdGVkU3ViamVjdCwgcmVzcG9uc2UsIHtcbiAgICAgICAgW29hdXRoLmp3ZURlY3J5cHRdOiBkZWNyeXB0LFxuICAgIH0pO1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgZXhlYztcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAocmV0cnlhYmxlKGVyciwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaFVzZXJJbmZvKGNvbmZpZywgYWNjZXNzVG9rZW4sIGV4cGVjdGVkU3ViamVjdCwge1xuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgZmxhZzogcmV0cnksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvckhhbmRsZXIoZXJyKTtcbiAgICB9XG4gICAgb2F1dGguZ2V0Q29udGVudFR5cGUocmVzcG9uc2UpID09PSAnYXBwbGljYXRpb24vand0JyAmJlxuICAgICAgICAoYXdhaXQgbm9uUmVwdWRpYXRpb24/LihyZXNwb25zZSkpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiByZXRyeWFibGUoZXJyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnM/LkRQb1AgJiYgb3B0aW9ucy5mbGFnICE9PSByZXRyeSkge1xuICAgICAgICByZXR1cm4gb2F1dGguaXNEUG9QTm9uY2VFcnJvcihlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdG9rZW5JbnRyb3NwZWN0aW9uKGNvbmZpZywgdG9rZW4sIHBhcmFtZXRlcnMpIHtcbiAgICBjaGVja0NvbmZpZyhjb25maWcpO1xuICAgIGNvbnN0IHsgYXMsIGMsIGF1dGgsIGZldGNoLCB0bHNPbmx5LCBub25SZXB1ZGlhdGlvbiwgdGltZW91dCwgZGVjcnlwdCB9ID0gaW50KGNvbmZpZyk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBvYXV0aFxuICAgICAgICAuaW50cm9zcGVjdGlvblJlcXVlc3QoYXMsIGMsIGF1dGgsIHRva2VuLCB7XG4gICAgICAgIFtvYXV0aC5jdXN0b21GZXRjaF06IGZldGNoLFxuICAgICAgICBbb2F1dGguYWxsb3dJbnNlY3VyZVJlcXVlc3RzXTogIXRsc09ubHksXG4gICAgICAgIGFkZGl0aW9uYWxQYXJhbWV0ZXJzOiBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtZXRlcnMpLFxuICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhoZWFkZXJzKSxcbiAgICAgICAgc2lnbmFsOiBzaWduYWwodGltZW91dCksXG4gICAgfSlcbiAgICAgICAgLmNhdGNoKGVycm9ySGFuZGxlcik7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb2F1dGhcbiAgICAgICAgLnByb2Nlc3NJbnRyb3NwZWN0aW9uUmVzcG9uc2UoYXMsIGMsIHJlc3BvbnNlLCB7XG4gICAgICAgIFtvYXV0aC5qd2VEZWNyeXB0XTogZGVjcnlwdCxcbiAgICB9KVxuICAgICAgICAuY2F0Y2goZXJyb3JIYW5kbGVyKTtcbiAgICBvYXV0aC5nZXRDb250ZW50VHlwZShyZXNwb25zZSkgPT09ICdhcHBsaWNhdGlvbi90b2tlbi1pbnRyb3NwZWN0aW9uK2p3dCcgJiZcbiAgICAgICAgKGF3YWl0IG5vblJlcHVkaWF0aW9uPy4ocmVzcG9uc2UpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgcmV0cnkgPSBTeW1ib2woKTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZW5lcmljR3JhbnRSZXF1ZXN0KGNvbmZpZywgZ3JhbnRUeXBlLCBwYXJhbWV0ZXJzLCBvcHRpb25zKSB7XG4gICAgY2hlY2tDb25maWcoY29uZmlnKTtcbiAgICBjb25zdCB7IGFzLCBjLCBhdXRoLCBmZXRjaCwgdGxzT25seSwgdGltZW91dCwgZGVjcnlwdCB9ID0gaW50KGNvbmZpZyk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb2F1dGhcbiAgICAgICAgLmdlbmVyaWNUb2tlbkVuZHBvaW50UmVxdWVzdChhcywgYywgYXV0aCwgZ3JhbnRUeXBlLCBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtZXRlcnMpLCB7XG4gICAgICAgIFtvYXV0aC5jdXN0b21GZXRjaF06IGZldGNoLFxuICAgICAgICBbb2F1dGguYWxsb3dJbnNlY3VyZVJlcXVlc3RzXTogIXRsc09ubHksXG4gICAgICAgIERQb1A6IG9wdGlvbnM/LkRQb1AsXG4gICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKGhlYWRlcnMpLFxuICAgICAgICBzaWduYWw6IHNpZ25hbCh0aW1lb3V0KSxcbiAgICB9KVxuICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgbGV0IHJlY29nbml6ZWRUb2tlblR5cGVzO1xuICAgICAgICBpZiAoZ3JhbnRUeXBlID09PSAndXJuOmlldGY6cGFyYW1zOm9hdXRoOmdyYW50LXR5cGU6dG9rZW4tZXhjaGFuZ2UnKSB7XG4gICAgICAgICAgICByZWNvZ25pemVkVG9rZW5UeXBlcyA9IHsgbl9hOiAoKSA9PiB7IH0gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2F1dGgucHJvY2Vzc0dlbmVyaWNUb2tlbkVuZHBvaW50UmVzcG9uc2UoYXMsIGMsIHJlc3BvbnNlLCB7XG4gICAgICAgICAgICBbb2F1dGguandlRGVjcnlwdF06IGRlY3J5cHQsXG4gICAgICAgICAgICByZWNvZ25pemVkVG9rZW5UeXBlcyxcbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAgICAgLmNhdGNoKGVycm9ySGFuZGxlcik7XG4gICAgYWRkSGVscGVycyhyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdG9rZW5SZXZvY2F0aW9uKGNvbmZpZywgdG9rZW4sIHBhcmFtZXRlcnMpIHtcbiAgICBjaGVja0NvbmZpZyhjb25maWcpO1xuICAgIGNvbnN0IHsgYXMsIGMsIGF1dGgsIGZldGNoLCB0bHNPbmx5LCB0aW1lb3V0IH0gPSBpbnQoY29uZmlnKTtcbiAgICByZXR1cm4gb2F1dGhcbiAgICAgICAgLnJldm9jYXRpb25SZXF1ZXN0KGFzLCBjLCBhdXRoLCB0b2tlbiwge1xuICAgICAgICBbb2F1dGguY3VzdG9tRmV0Y2hdOiBmZXRjaCxcbiAgICAgICAgW29hdXRoLmFsbG93SW5zZWN1cmVSZXF1ZXN0c106ICF0bHNPbmx5LFxuICAgICAgICBhZGRpdGlvbmFsUGFyYW1ldGVyczogbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbWV0ZXJzKSxcbiAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoaGVhZGVycyksXG4gICAgICAgIHNpZ25hbDogc2lnbmFsKHRpbWVvdXQpLFxuICAgIH0pXG4gICAgICAgIC50aGVuKG9hdXRoLnByb2Nlc3NSZXZvY2F0aW9uUmVzcG9uc2UpXG4gICAgICAgIC5jYXRjaChlcnJvckhhbmRsZXIpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoUHJvdGVjdGVkUmVzb3VyY2UoY29uZmlnLCBhY2Nlc3NUb2tlbiwgdXJsLCBtZXRob2QsIGJvZHksIGhlYWRlcnMsIG9wdGlvbnMpIHtcbiAgICBjaGVja0NvbmZpZyhjb25maWcpO1xuICAgIGhlYWRlcnMgfHw9IG5ldyBIZWFkZXJzKCk7XG4gICAgaWYgKCFoZWFkZXJzLmhhcygndXNlci1hZ2VudCcpKSB7XG4gICAgICAgIGhlYWRlcnMuc2V0KCd1c2VyLWFnZW50JywgVVNFUl9BR0VOVCk7XG4gICAgfVxuICAgIGNvbnN0IHsgZmV0Y2gsIHRsc09ubHksIHRpbWVvdXQgfSA9IGludChjb25maWcpO1xuICAgIGNvbnN0IGV4ZWMgPSBvYXV0aC5wcm90ZWN0ZWRSZXNvdXJjZVJlcXVlc3QoYWNjZXNzVG9rZW4sIG1ldGhvZCwgdXJsLCBoZWFkZXJzLCBib2R5LCB7XG4gICAgICAgIFtvYXV0aC5jdXN0b21GZXRjaF06IGZldGNoLFxuICAgICAgICBbb2F1dGguYWxsb3dJbnNlY3VyZVJlcXVlc3RzXTogIXRsc09ubHksXG4gICAgICAgIERQb1A6IG9wdGlvbnM/LkRQb1AsXG4gICAgICAgIHNpZ25hbDogc2lnbmFsKHRpbWVvdXQpLFxuICAgIH0pO1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgZXhlYztcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAocmV0cnlhYmxlKGVyciwgb3B0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaFByb3RlY3RlZFJlc291cmNlKGNvbmZpZywgYWNjZXNzVG9rZW4sIHVybCwgbWV0aG9kLCBib2R5LCBoZWFkZXJzLCB7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBmbGFnOiByZXRyeSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVycm9ySGFuZGxlcihlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/openid-client@6.8.1/node_modules/openid-client/build/index.js\n");

/***/ })

};
;